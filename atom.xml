<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShengFu&#39;s blog</title>
  
  <subtitle>前端，Javascript，html，css,html5,Vue,React,Angular</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-02T10:50:07.331Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShengFu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手写call,apply,bind</title>
    <link href="http://yoursite.com/2021/01/02/call/"/>
    <id>http://yoursite.com/2021/01/02/call/</id>
    <published>2021-01-02T10:50:07.331Z</published>
    <updated>2021-01-02T10:50:07.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.rawpixel.com/s3fs-private/rawpixel_images/website_content/k-199-eye-006547-l_2.jpg?auto=format&amp;bg=F4F4F3&amp;con=3&amp;cs=srgb&amp;dpr=1&amp;fm=jpg&amp;ixlib=php-1.1.0&amp;mark=rawpixel-watermark.png&amp;markalpha=90&amp;markpad=13&amp;markscale=10&amp;markx=25&amp;q=75&amp;usm=15&amp;vib=3&amp;w=1600&amp;s=4ff36d0e064c667b6455097787e90f01" alt=""><br><a id="more"></a><br>在日常开发中，bind,call,apply这三个函数是使用率比较高的函数，它们都可以改变函数都执行作用域（改变this），那么我们知道它们是如何实现都吗，下面我们来手动实现以下这三个函数：<br><a name="06f1ca97"></a></p><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call,apply"></a>call,apply</h2><p>根据MDN的描述，call 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。call 和 apply 的具体功能相同，唯一的区别是传参方式不一样。call 传参数是分开的，apply 是用一个组数传递参数。下面是这两个函数的具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> args = [...arr].slice(<span class="number">1</span>);</span><br><span class="line">      result = context.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bind"></a></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>根据MDN描述，bind 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _self(...args,...arguments);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _self.apply(context,[...args,...arguments]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.rawpixel.com/s3fs-private/rawpixel_images/website_content/k-199-eye-006547-l_2.jpg?auto=format&amp;amp;bg=F4F4F3&amp;amp;con=3&amp;amp;cs=srgb&amp;amp;dpr=1&amp;amp;fm=jpg&amp;amp;ixlib=php-1.1.0&amp;amp;mark=rawpixel-watermark.png&amp;amp;markalpha=90&amp;amp;markpad=13&amp;amp;markscale=10&amp;amp;markx=25&amp;amp;q=75&amp;amp;usm=15&amp;amp;vib=3&amp;amp;w=1600&amp;amp;s=4ff36d0e064c667b6455097787e90f01&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>3分钟带你体验Vue3.0</title>
    <link href="http://yoursite.com/2019/10/14/composition-api/"/>
    <id>http://yoursite.com/2019/10/14/composition-api/</id>
    <published>2019-10-14T02:06:21.000Z</published>
    <updated>2021-01-02T10:50:07.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cn.bing.com/th?id=OIP.i4gA6AP8gT3IDQsg--LLBwHaGa&amp;pid=Api&amp;rs=1" alt=""><br><a id="more"></a></p><p>最近，Vue官方发布了 <a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener">Composition API RFC</a>。有关于Vue3.0 Function Base组件相关讨论正如火如荼。虽然Vue3.0还未发布，但是 Vue官方发布了关于 Composition API的官方插件，使广大用户可以在Vue2.x中享受 Function Base 带来的新体验。下面我会在一个简单的demo中介绍Composition API使用方法。</p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @vue/composition-api</span><br></pre></td></tr></table></figure><p>等待composition-api包安装完成后，我们在项目入口文件中加入Composition API。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> CompositionApi <span class="keyword">from</span> <span class="string">"@vue/composition-api"</span></span><br><span class="line">Vue.use(CompositionApi)</span><br></pre></td></tr></table></figure></p><h2 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h2><p>按照官方给出的说法，setup函数是一个新的Vue组件选项，是用于在组件中使用Composition API的入口。</p><blockquote><p>setup函数在组件初始化了props之后，created之前调用，这时候我们才能通过setup来传递props。</p></blockquote><h2 id="绑定数据-data"><a href="#绑定数据-data" class="headerlink" title="绑定数据(data)"></a>绑定数据(data)</h2><p><code>ref</code>是CompositionAPI引入的新概念。作用是使访问响应式的变量不依赖于实例的<code>this</code>。如果使用了<code>ref</code>，我们访问响应式的变量时使用<code>.value</code>而不是从<code>this</code>中获取。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">"@vue/composition-apai"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> count = ref(<span class="number">0</span>)<span class="comment">//count初始值为0，会相应变化</span></span><br><span class="line">        count.value = <span class="number">10</span>;<span class="comment">//设置count值为10，使用.value形式</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count<span class="comment">//必须将count return 回去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="绑定生命周期函数"><a href="#绑定生命周期函数" class="headerlink" title="绑定生命周期函数"></a>绑定生命周期函数</h2><p>可以使用导入的<code>onXXX</code>的形式注册生命周期函数，举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;onCreated,onMounted&#125; <span class="keyword">from</span> <span class="string">"@vue/composition-apai"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        onCreated(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'created被触发'</span>)    </span><br><span class="line">        &#125;)</span><br><span class="line">        onMounted(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'mounted被触发'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">///...其他类似</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="绑定方法-methods"><a href="#绑定方法-methods" class="headerlink" title="绑定方法(methods)"></a>绑定方法(methods)</h2><p>在Composition API中，我们使用普通的函数定义方法，这样可以最大程度的增加复用性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button @click=&quot;add&quot;&gt;click me!&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        function add() &#123;</span><br><span class="line">            console.log(&apos;add被触发&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            add//必须将函数return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="外部属性-props"><a href="#外部属性-props" class="headerlink" title="外部属性(props)"></a>外部属性(props)</h2><p>定义<code>props</code>和原来的方式一样，<code>props</code>会通过参数的形式传入到<code>setup</code>函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        name:<span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性(computed)"></a>计算属性(computed)</h2><p>计算属性可以使用Composition API提供的<code>computed</code>函数进行定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed,ref&#125; <span class="keyword">from</span> <span class="string">"@vue/composition-apai"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> a = ref(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">const</span> b = ref(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> total = computed(<span class="function"><span class="params">()</span>=&gt;</span>a.value+b.value)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a,</span><br><span class="line">            b,</span><br><span class="line">            totla</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就定义号了一个计算属性<code>total</code>，<code>total.value = a.value + b.value</code>。</p><h2 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器(watch)"></a>侦听器(watch)</h2><p>在组件中添加<code>watch</code>监听我们可以采用Composition API提供的<code>watch</code>函数实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;watch,ref&#125; <span class="keyword">from</span> <span class="string">"@vue/composition-apai"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> count = ref(<span class="number">100</span>);</span><br><span class="line">        watch(<span class="function"><span class="params">()</span>=&gt;</span>count.vlaue,()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'count数值发生变化了'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span>.value = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实例属性-refs"><a href="#实例属性-refs" class="headerlink" title="实例属性($refs)"></a>实例属性($refs)</h2><p>在Composition API中使用<code>ref</code>特性获取组件实例或者dom节点，举个例子说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;hello-world ref=&quot;helloWold&quot;&gt;&lt;/hello-world&gt;</span><br><span class="line">    &lt;button ref=&quot;btn&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import &#123;ref&#125; from &quot;@vue/composition-api&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const helloWorld = ref(null);//helloworld组件实例</span><br><span class="line">        const btn = ref(null);//button dom节点对象</span><br><span class="line">        return &#123;</span><br><span class="line">            btn,</span><br><span class="line">            helloWorld</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="综合例子"><a href="#综合例子" class="headerlink" title="综合例子"></a>综合例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button @click=&quot;increment&quot; ref=&quot;btn&quot;&gt;&#123;&#123;titleCount&#125;&#125;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">import &#123;onMounted,computed,ref,watch&#125; from &quot;@vue/composition-api&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  props:&#123;</span><br><span class="line">    prefix:String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    const btn = ref(null);</span><br><span class="line">    const count = ref(0);</span><br><span class="line">    const title = ref(`$&#123;props.prefix&#125;,vue composition api`);</span><br><span class="line">    const titleCount = computed(()=&gt;title.value +&apos;:&apos;+ count.value)</span><br><span class="line">    onMounted(()=&gt;&#123;</span><br><span class="line">      alert(&apos;mounted&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    watch(()=&gt;count.value,()=&gt;alert(&apos;count改变了:&apos;+count.value))</span><br><span class="line">    function increment() &#123;</span><br><span class="line">      // eslint-disable-next-line no-console</span><br><span class="line">      count.value++;</span><br><span class="line">      // eslint-disable-next-line no-console</span><br><span class="line">      console.log(btn.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      btn,</span><br><span class="line">      increment,</span><br><span class="line">      title,</span><br><span class="line">      count,</span><br><span class="line">      titleCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>下图是运行效果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/4/16cfba9df1d90cbf?w=541&amp;h=393&amp;f=gif&amp;s=304128" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上实践，总结Composition API以下特点：</p><p>优点：</p><ol><li>使用简洁，方便，代码量小</li><li>函数特性，复用性强</li><li>容易做类型推导，方便IDE做出语法提示</li></ol><p>缺点：</p><ol><li>需要额外加载composition-api包文件，增加了打包后的文件体积，对网页性能有一定影响</li><li>增加了一定的学习成本</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cn.bing.com/th?id=OIP.i4gA6AP8gT3IDQsg--LLBwHaGa&amp;amp;pid=Api&amp;amp;rs=1&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js栈内存与堆内存</title>
    <link href="http://yoursite.com/2019/07/11/js-stack-heap/"/>
    <id>http://yoursite.com/2019/07/11/js-stack-heap/</id>
    <published>2019-07-11T08:47:16.000Z</published>
    <updated>2021-01-02T10:50:07.333Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/11/5d26f7b563f5933746.png" alt="js-stack-and-heap"><br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Javscript中内存分为栈内存、堆内存与池三类。在创建变量时，不同类型的变量会被分配到不同类型的内存当中。</p><h2 id="栈内存-stack"><a href="#栈内存-stack" class="headerlink" title="栈内存(stack)"></a>栈内存(stack)</h2><p>栈内存有以下特点：</p><ol><li>大小固定</li><li>“先进后出”</li><li>运行效率高</li></ol><p>什么类型的变量会被放到栈内存当中呢？由于栈内存大小固定，所以基本类型和引用类型地址会存放大到栈内存中。在栈内存中存放的变量使用完会被立即释放。</p><h2 id="堆内存-heap"><a href="#堆内存-heap" class="headerlink" title="堆内存(heap)"></a>堆内存(heap)</h2><p>堆内存的大小是可变的，浏览器在必要的时候会动态给堆内存分配空间。例如，我们创建一个对象，由于在Javascript中，对象存放的数据是可变的，可能会在未来被修改，所以引用类型的数据会被存放到堆内存中,而该引用的地址会被放到栈内存中，当需要访问该对象时，js引擎会先去访问该对象的引用地址，拿到地址之后再根据该地址去堆内存中访问该对象。除此之外，闭包在创建完成后由于引用了其他变量，所以无法立即释放，也会存放到堆内存当中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/11/5d26f7b563f5933746.png&quot; alt=&quot;js-stack-and-heap&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理与性能优化</title>
    <link href="http://yoursite.com/2019/07/11/browser-render/"/>
    <id>http://yoursite.com/2019/07/11/browser-render/</id>
    <published>2019-07-11T08:31:10.000Z</published>
    <updated>2021-01-02T10:50:07.331Z</updated>
    
    <content type="html"><![CDATA[<p><a name="jvcUz"></a></p><h2 id="HTML、CSS渲染过程"><a href="#HTML、CSS渲染过程" class="headerlink" title="HTML、CSS渲染过程"></a>HTML、CSS渲染过程</h2><p>DOM构建过程：字符数据-&gt;字符串-&gt;Token(标记)-&gt;Node-&gt;DOM树</p><p>CSSOM构建过程：字符数据-&gt;字符串-&gt;Token(标记)-&gt;Node-&gt;CSSOM树</p><blockquote><p>DOM树和CSSOM树组合为渲染树<br>display：none 不会在渲染树中显示</p></blockquote><p><a name="TTvxc"></a></p><h2 id="为什么操作DOM慢？"><a href="#为什么操作DOM慢？" class="headerlink" title="为什么操作DOM慢？"></a>为什么操作DOM慢？</h2><p>DOM树属于渲染引擎，JS属于JS引擎，操作DOM树要在两个引擎的线程之间通信<br><a name="XFfyi"></a></p><h2 id="插入大数据量DOM节点，如何做到不卡顿？"><a href="#插入大数据量DOM节点，如何做到不卡顿？" class="headerlink" title="插入大数据量DOM节点，如何做到不卡顿？"></a>插入大数据量DOM节点，如何做到不卡顿？</h2><p>方式1：采用requestAnimation循环插入DOM<br>方式2：虚拟滚动，只展示用户看到的DOM<br><a name="PBDD2"></a></p><h2 id="什么情况阻塞渲染？"><a href="#什么情况阻塞渲染？" class="headerlink" title="什么情况阻塞渲染？"></a>什么情况阻塞渲染？</h2><p>当浏览器解析到script标签，会暂停DOM构建，进行脚本下载和解析，完成后继续构建DOM<br>解决方式：</p><ol><li>将script标签放到body底部</li><li>加defer属性，浏览器会并行下载js文件，在HTML解析完成后执行</li><li>加async属性，表示JS下载和解析不会影响渲染执行<br><a name="06uxZ"></a></li></ol><h2 id="重绘-repaint-和回流-reflow"><a href="#重绘-repaint-和回流-reflow" class="headerlink" title="重绘(repaint)和回流(reflow)"></a>重绘(repaint)和回流(reflow)</h2><ol><li>重绘指当节点需要改变外观但是不会影响布局时发生，比如color</li><li>回流指当节点的几何属性会布局变化时发生</li></ol><p>重绘不一定引起回流，但是回流一定会引发重绘，所以<strong> 回流的成本大于重绘</strong></p><p>以下几点需要注意：</p><ol><li>改变window大小</li><li>改变字体</li><li>添加、删除、修改样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型改变</li></ol><p><a name="NP8JC"></a></p><h2 id="重绘回流与EventLoop关系"><a href="#重绘回流与EventLoop关系" class="headerlink" title="重绘回流与EventLoop关系"></a>重绘回流与EventLoop关系</h2><ol><li>当 Eventloop 执行完 Microtasks 后，会判断 <code>document</code> 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> 事件，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 media query</li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调。</li></ol><p><a name="NJ920"></a></p><h2 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h2><ol><li>使用transform</li><li>visibility 代替 display:none ,前者引起重绘，后者引起回流</li><li>不要在循环中获取节点offsetTop等属性（会导致回流）</li><li>不要使用table布局，小改动会引发整个table回流</li><li>动画实现速度越快，回流越多，使用requestAnimationFrame</li><li>将频繁重绘或者回流的节点设置为图层</li></ol><p>设置为图层的方法：</p><ol><li>will-change</li><li>使用video、iframe</li></ol><p><a name="igA5i"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在不考虑缓存和优化网络协议的前提下，考虑可以通过哪些方式来最快的渲染页面，也就是常说的 <a href="https://juejin.im/entry/5b16a05fe51d4506b01106d9" target="_blank" rel="noopener">关键路径渲染</a>，这部分也是性能优化中的一块内容</p><p>提前DOMContentLoaded时间发生时间，该时间发生后就会生成渲染树渲染，与硬件关系较大，优化空间小</p><p>解决方向：</p><ol><li>从文件大小考虑</li><li>从script标签考虑</li><li>从Html,css代码书写考虑</li><li>从需要下载的内容是否在首屏上使用考虑</li></ol><p>css从右向左解析，因此css需要扁平化。html嵌套层级不应该太多，减少嵌套层级</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a name=&quot;jvcUz&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;HTML、CSS渲染过程&quot;&gt;&lt;a href=&quot;#HTML、CSS渲染过程&quot; class=&quot;headerlink&quot; title=&quot;HTML、CSS渲染过程&quot;&gt;&lt;/a&gt;HTML、CSS渲染过程&lt;/h2&gt;&lt;p&gt;DO
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Verdaccio 搭建私有 npm 服务</title>
    <link href="http://yoursite.com/2019/05/15/verdaccio/"/>
    <id>http://yoursite.com/2019/05/15/verdaccio/</id>
    <published>2019-05-15T14:13:09.000Z</published>
    <updated>2021-01-02T10:50:07.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要搭建npm私服？"><a href="#为什么要搭建npm私服？" class="headerlink" title="为什么要搭建npm私服？"></a>为什么要搭建npm私服？</h2><p>假如我们由于平时的技术积累，写了一些可以复用的工具，我们想分享给公司其它同事使用；或者我们公司可能会有一个公共组件仓库，我们想用npm的方式安装而不是去简单的拷贝文件；然而，这些工具或者组件都涉及公司内部的机密，这时我们就可以搭建一个npm私服，只在公司局域网访问，我们可以将我们写好的工具发布到上面，方便其它同事安装使用。当访问到本地npm没有的包时,verdaccio会根据设置的远程仓库路径下载（远程仓库可以通过配置文件修改），之后将下载完成的包缓存到本地，当下一次安装同样的包时就可以直接从本地缓存获取了。</p><h2 id="为什么要选verdaccio"><a href="#为什么要选verdaccio" class="headerlink" title="为什么要选verdaccio?"></a>为什么要选verdaccio?</h2><p>目前，市面上用来搭建npm私服的工具有大体三种：</p><ol><li>nexus</li><li>cnpm</li><li>verdaccio</li></ol><p>nexus功能强大，但是部署和配置较繁琐，不符合我们的使用要求。cnpm虽然比nexus配置简单，但是也需要使用到mysql。有没有更好用的工具呢？那就是verdaccio。verdaccio使用文件存储包数据，无需安装数据库并且部署简单，只需要一行代码就可以部署完成，这个正是我们需要的。</p><h2 id="verdaccio部署"><a href="#verdaccio部署" class="headerlink" title="verdaccio部署"></a>verdaccio部署</h2><p>首先，假设我们已经在服务器端安装了nodejs和npm。下面我们来讲讲verdaccio的部署。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g verdaccio</span><br><span class="line"></span><br><span class="line"><span class="comment">## 初始化</span></span><br><span class="line">verdaccio --init ~/verdaccio.config.js</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行verdaccio</span></span><br><span class="line">verdaccio</span><br></pre></td></tr></table></figure></p><p>下面我们用浏览器访问 <a href="http://localhost:4873，如果我们看到这样的界面，说明我们已经部署成功。" target="_blank" rel="noopener">http://localhost:4873，如果我们看到这样的界面，说明我们已经部署成功。</a><br><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557931029943-6dd03fc1-aeb2-4d83-b0ad-d502428bfb79.png" alt=""></p><h2 id="使用pm2启动"><a href="#使用pm2启动" class="headerlink" title="使用pm2启动"></a>使用pm2启动</h2><p>pm2 是一款著名的nodejs进程守护和管理工具，下面我们用pm2来启动verdaccio:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pm2启动</span></span><br><span class="line">pm2 start verdaccio</span><br></pre></td></tr></table></figure></p><p>启动成功后会输出以下内容<br><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557931365700-4fcfaef9-8d1a-4f88-be1d-f6ae444a9fb6.png" alt=""></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>为了方便切换npm仓库地址，我们使用nrm。首先，我们来安装nrm。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure></p><p>下面，我们使用nrm管理npm仓库原地址，我们使用verdaccio地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm add <span class="built_in">local</span> http://localhost:4873 <span class="comment"># 添加远程仓库源</span></span><br><span class="line">nrm use <span class="built_in">local</span> <span class="comment"># 使用该仓库源</span></span><br></pre></td></tr></table></figure><p>这样，我们就成功将npm的仓库地址换成了我们最新搭建的私服地址。🍺</p><h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><p>在发布包之前，我们首先需要新建用户。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm adduser</span><br></pre></td></tr></table></figure></p><p>在输入用户名、密码和邮箱后，我们成功在我们本地的npm私服创建了用户。</p><p>下面我们来发布一个npm包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish &lt;npm_pkg_name&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我们发布完成后，包的内容会显示在网页上，这样我们就完成来verdaccio的基本使用操作。下次使用这个包的时候，我们可以直接运行<code>npm install</code>，由于之前我们已经使用nrm修改了仓库源的地址，所以npm会从我们刚搭的私服上面获取对应的包文件，这样我们就可以愉快的在局域网私服上面发布自己写的包了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要搭建npm私服？&quot;&gt;&lt;a href=&quot;#为什么要搭建npm私服？&quot; class=&quot;headerlink&quot; title=&quot;为什么要搭建npm私服？&quot;&gt;&lt;/a&gt;为什么要搭建npm私服？&lt;/h2&gt;&lt;p&gt;假如我们由于平时的技术积累，写了一些可以复用的工具，我们想分
      
    
    </summary>
    
      <category term="node.js" scheme="http://yoursite.com/categories/node-js/"/>
    
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
      <category term="包管理工具" scheme="http://yoursite.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://yoursite.com/2019/05/15/flex/"/>
    <id>http://yoursite.com/2019/05/15/flex/</id>
    <published>2019-05-15T14:06:44.000Z</published>
    <updated>2021-01-02T10:50:07.333Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557043900778-3b2a263e-8954-46b3-90ab-4f397829164a.png#align=left&amp;display=inline&amp;height=368&amp;name=&amp;originHeight=368&amp;originWidth=700&amp;size=0&amp;status=done&amp;width=700" alt=""><br><a id="more"></a><br><a name="NeX6P"></a></p><h2 id="网页布局的几种形式"><a href="#网页布局的几种形式" class="headerlink" title="网页布局的几种形式"></a>网页布局的几种形式</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/149846/1557043924903-f495d09b-5899-471b-97be-8c4ecdc5ee96.gif#align=left&amp;display=inline&amp;height=352&amp;originHeight=352&amp;originWidth=403&amp;size=0&amp;status=done&amp;width=403" alt=""></p><p><a name="P5op4"></a></p><h2 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h2><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 </p></blockquote><p><br><br><a name="MtOuB"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557044027503-3f6860b4-e0bc-4fd4-8c79-fd518f4af2cb.png#align=left&amp;display=inline&amp;height=333&amp;originHeight=333&amp;originWidth=563&amp;size=0&amp;status=done&amp;width=563" alt=""></p><blockquote><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。<br><a name="X9zBa"></a></p></blockquote><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>总共有以下6个属性可以设置到容器上面：</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p><a name="a2q9t"></a></p><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557044282298-14888d63-8acf-4087-9333-38af954e196e.png#align=left&amp;display=inline&amp;height=203&amp;originHeight=203&amp;originWidth=796&amp;size=0&amp;status=done&amp;width=796" alt=""></p><ul><li>row(默认）：主轴为水平方向，起点在左端</li><li>row-reverse：主轴为水平方向，起点在右端</li><li>column：主轴为垂直方向，起点在上端</li><li>column-reverse：主轴为垂直方向，起点在下端<br><a name="lQiiS"></a><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557233753425-6e74825b-ca5c-4f19-866e-ef37ef3f25cf.png#align=left&amp;display=inline&amp;height=276&amp;originHeight=276&amp;originWidth=798&amp;size=0&amp;status=done&amp;width=798" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="J81i8"></a></p><h4 id="nowrap-默认-不换行"><a href="#nowrap-默认-不换行" class="headerlink" title="nowrap(默认):不换行"></a>nowrap(默认):不换行</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557233848091-df395156-ced1-421a-8dfa-5ffe95dae6a2.png#align=left&amp;display=inline&amp;height=145&amp;originHeight=145&amp;originWidth=700&amp;size=0&amp;status=done&amp;width=700" alt=""><br><a name="GjMER"></a></p><h4 id="wrap：换行，第一行在上方"><a href="#wrap：换行，第一行在上方" class="headerlink" title="wrap：换行，第一行在上方"></a>wrap：换行，第一行在上方</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149846/1557233878922-de4d42c3-258d-41ec-9509-b20835517050.jpeg#align=left&amp;display=inline&amp;height=177&amp;originHeight=177&amp;originWidth=700&amp;size=0&amp;status=done&amp;width=700" alt=""><br><a name="nVXde"></a></p><h4 id="wrap-reverse-换行，起点在下方"><a href="#wrap-reverse-换行，起点在下方" class="headerlink" title="wrap-reverse:换行，起点在下方"></a>wrap-reverse:换行，起点在下方</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149846/1557233912083-d25dce3d-87f3-45b9-840e-f2bfdf95e66d.jpeg#align=left&amp;display=inline&amp;height=177&amp;originHeight=177&amp;originWidth=700&amp;size=0&amp;status=done&amp;width=700" alt=""></p><p><a name="0dosE"></a></p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Ljeml"></a></p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>justify-content属性定义了项目在主轴上的对齐方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557234002760-78b6671c-114c-4c67-ba4e-f6a2b956fb74.png#align=left&amp;display=inline&amp;height=763&amp;originHeight=763&amp;originWidth=637&amp;size=0&amp;status=done&amp;width=637" alt=""><br><a name="FksvN"></a></p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>align-items属性定义项目在交叉轴上如何对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557234033894-10c234d9-598b-4d30-8667-a4fbee9591ad.png#align=left&amp;display=inline&amp;height=786&amp;originHeight=786&amp;originWidth=617&amp;size=0&amp;status=done&amp;width=617" alt=""></p><p><a name="Y5drG"></a></p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557234078863-280e5542-a066-495f-9117-a02194f30943.png#align=left&amp;display=inline&amp;height=786&amp;originHeight=786&amp;originWidth=620&amp;size=0&amp;status=done&amp;width=620" alt=""></p><p><a name="qXvfv"></a></p><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><p><a name="fZapQ"></a></p><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557234181234-96d0c576-072e-49bd-bee9-258009e6fb3f.png#align=left&amp;display=inline&amp;height=480&amp;originHeight=480&amp;originWidth=751&amp;size=0&amp;status=done&amp;width=751" alt=""><br><a name="0SKRx"></a></p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557234215075-686f89e8-ac26-4a63-b3e1-414d3b9326f8.png#align=left&amp;display=inline&amp;height=211&amp;originHeight=211&amp;originWidth=802&amp;size=0&amp;status=done&amp;width=802" alt=""></p><p><a name="v78Yc"></a></p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149846/1557234231293-4f7fdd4d-f1c0-406b-b30a-a6da6035e443.jpeg#align=left&amp;display=inline&amp;height=145&amp;originHeight=145&amp;originWidth=700&amp;size=0&amp;status=done&amp;width=700" alt=""></p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p><p><a name="uvPY4"></a></p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><p><a name="M0gWq"></a></p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p><p><a name="ygfYK"></a></p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1557234270481-ed101ca1-cedc-41ae-863c-ce7b616212a9.png#align=left&amp;display=inline&amp;height=390&amp;originHeight=390&amp;originWidth=743&amp;status=done&amp;width=743" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/149846/1557043900778-3b2a263e-8954-46b3-90ab-4f397829164a.png#align=left&amp;amp;display=inline&amp;amp;height=368&amp;amp;name=&amp;amp;originHeight=368&amp;amp;originWidth=700&amp;amp;size=0&amp;amp;status=done&amp;amp;width=700&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="Flex" scheme="http://yoursite.com/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>基于Mocha的单元测试实践</title>
    <link href="http://yoursite.com/2019/04/08/%E5%9F%BA%E4%BA%8EMocha%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/04/08/基于Mocha的单元测试实践/</id>
    <published>2019-04-08T13:05:12.000Z</published>
    <updated>2021-01-02T10:50:07.335Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/374147/pexels-photo-374147.jpeg?cs=srgb&amp;dl=beverage-caffeine-cappuccino-374147.jpg&amp;fm=jpg" alt="Mocha"><br><a id="more"></a></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>在日常开发中，我们常会遇到项目上线迫在眉睫，没有足够的测试时间或者在创业公司做敏捷开发，完全没有测试人员的情况，但我们又必须保证代码质量，尽量减少上线风险，这时我们应该怎么办呢？答案是我们采用测试驱动开发，简称TDD的开发模式。顾名思义，TDD就是 “Test Drive Develop”，在正式开发产品功能前先写单元测试用例，用这些测试用例去保证我们代码的质量，这样就算产品不经过正式测试，我们也对代码中的关键部分可以做到知根知底，将风险控制到一定范围内。那么在Javascript中有一款特别有名的测试框架：Mocha，下面我们就来通过一个例子简单介绍下Mocha的使用方法。</p><h2 id="Mocha安装"><a href="#Mocha安装" class="headerlink" title="Mocha安装"></a>Mocha安装</h2><p>Mocha可以全局安装也可以局部安装。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局安装</span></span><br><span class="line">npm install -g mocha</span><br><span class="line"><span class="comment">#局部安装</span></span><br><span class="line">npm install mocha --save-dev</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面我们来编写单元测试用例。我们新建用于测试的js文件，并添加我们需要测试的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a,b </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = add;</span><br></pre></td></tr></table></figure></p><p>下面我们先安装下断言库，我们使用chai:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装chai</span></span><br><span class="line">npm install chai --save-dev</span><br></pre></td></tr></table></figure></p><p>之后，我们编写单元测试用例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> should = <span class="built_in">require</span>(<span class="string">"chai"</span>).should();</span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">describe(<span class="string">"function test"</span>,()=&gt;&#123;</span><br><span class="line">    it(<span class="string">"test add function"</span>,()=&gt;&#123;</span><br><span class="line">        add(<span class="number">1</span>,<span class="number">2</span>).should.to.equal(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>假设我们局部安装mocha,我们运行如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx mocha test1.js</span><br></pre></td></tr></table></figure></p><p>之后，我们会得到如下结果：</p><p>function test<br>    ✓ test add function</p><p>  1 passing (22ms)</p><p>假如我们将上面的断言改成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">2</span>).should.to.equal(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>我们将得到如下结果：<br> function test<br>    1) test add function</p><p>  0 passing (22ms)<br>  1 failing<br>第一个说明测试成功，第二个结果说明测试失败，这样也就验证了我们写的函数是否得到了正确的输出。但是这样还不够，因为我们虽然验证了函数的正确性，但是却不知道我们编写的测试用例覆盖了多少功能，所以我们必须得到覆盖率来保证我们所有的代码都正常运行。我们需要另外安装一个测试覆盖率检测工具：nyc<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nyc --save-dev</span><br></pre></td></tr></table></figure></p><p>然后我们运行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nyc mocha test1.js</span><br></pre></td></tr></table></figure></p><p>我们会得到如下输出：</p><p>———-|———-|———-|———-|———-|——————-|<br>File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |<br>———-|———-|———-|———-|———-|——————-|<br>All files |      100 |      100 |      100 |      100 |                   |<br> test1.js |      100 |      100 |      100 |      100 |                   |<br>———-|———-|———-|———-|———-|——————-|</p><p>好了，由于时间关系，今天就说到这里吧。关于 Mocha 和 Chai 这里还有很多知识没有覆盖到，我会在之后陆续更新～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/374147/pexels-photo-374147.jpeg?cs=srgb&amp;amp;dl=beverage-caffeine-cappuccino-374147.jpg&amp;amp;fm=jpg&quot; alt=&quot;Mocha&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="单元测试" scheme="http://yoursite.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Mocha" scheme="http://yoursite.com/tags/Mocha/"/>
    
  </entry>
  
  <entry>
    <title>Vue dispatch、broaddcast、event-bus实现</title>
    <link href="http://yoursite.com/2019/04/07/dispatch/"/>
    <id>http://yoursite.com/2019/04/07/dispatch/</id>
    <published>2019-04-07T14:19:48.000Z</published>
    <updated>2021-01-02T10:50:07.332Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://get.pxhere.com/photo/photography-wallpaper-portrait-landscape-cute-lovely-happy-alive-natural-beautiful-beauty-live-hair-green-girl-hairstyle-black-hair-long-hair-hair-coloring-brown-hair-1452521.jpg" alt="Vue dispatch、broaddcast、event-bus实现"><br><a id="more"></a><br><a name="820f8de7"></a></p><h2 id="为什么要实现dispatch、broadcast和event-bus？"><a href="#为什么要实现dispatch、broadcast和event-bus？" class="headerlink" title="为什么要实现dispatch、broadcast和event-bus？"></a>为什么要实现dispatch、broadcast和event-bus？</h2><p>在使用Vue的过程中，我们经常会遇到组件之间的通信。父、子组件通信我们可以使用props和event实现，但是如果组件层级跨度较大或者是兄弟组件之间通信时，如果我们还是使用props和event一层一层传递的话，就会造成代码难以维护、难以阅读以及更容易出错的问题。那么我们有更好的解决方案吗？当然有，那就是dispatch、broadcast与event-bus。<br><a name="6028afbe"></a></p><h2 id="dispatch、broadcast、event-bus各自的使用场景是什么？"><a href="#dispatch、broadcast、event-bus各自的使用场景是什么？" class="headerlink" title="dispatch、broadcast、event-bus各自的使用场景是什么？"></a>dispatch、broadcast、event-bus各自的使用场景是什么？</h2><p>先来说说dispatch和broadcast吧。<br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1554645955932-1a1514a2-d036-4289-b067-8e320efd0172.png#align=left&amp;display=inline&amp;height=249&amp;name=image.png&amp;originHeight=498&amp;originWidth=669&amp;size=23532&amp;status=done&amp;width=335" alt="image.png"><br>dispatch的作用是将事件向上传递。比如说如果一个组件触发事件的话，该事件会一层层向上传递到所有的父组件。broadcast正好和dispatch想法，broadcast的作用是向下面所有的子组件广播事件。如果实现了dispatch和broadcast，那么我们便不用props和events一层一层的通信了。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1554646459281-4e06cae8-1ec5-4bb0-a5d1-135fc3a5adf8.png#align=left&amp;display=inline&amp;height=141&amp;name=image.png&amp;originHeight=281&amp;originWidth=705&amp;size=14241&amp;status=done&amp;width=353" alt="image.png"><br><br>event-bus称为事件总线，其作用是在两个毫无关联的组件之间传递数据。event-bus就像一个事件的共享池，所有的组件都可以在event-bus上面订阅和发布事件，这样就实现了两个毫无管理的组件数据传递，其核心思想就是“订阅-发布”模式。</p><p><a name="b28c6524"></a></p><h2 id="如何实现dispatch、broadcast和event-bus？"><a href="#如何实现dispatch、broadcast和event-bus？" class="headerlink" title="如何实现dispatch、broadcast和event-bus？"></a>如何实现dispatch、broadcast和event-bus？</h2><p>dispatch的目的是要向所有的父组件传递事件，那么我们可以通过递归所有的父组件来实现,这里我们借助$parent获取父组件实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch(event,data) &#123;</span><br><span class="line"><span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent;</span><br><span class="line">  <span class="keyword">while</span>(parent) &#123;</span><br><span class="line">  <span class="keyword">if</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(event,data);</span><br><span class="line">      parent = parent.$parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.$dispatch = dispatch;</span><br></pre></td></tr></table></figure><p>broadcast的作用是向下级组件广播事件，我们借助$children获取下级组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">event,data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> children = <span class="keyword">this</span>.$children;</span><br><span class="line">  children.forEach(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">  child.$emit(event,data);</span><br><span class="line">    <span class="keyword">if</span>(child.$children.length) &#123;</span><br><span class="line">    broadcast.call(child,event,data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.$broadcast = boardcast;</span><br></pre></td></tr></table></figure><p>event-bus的实现是借助于“订阅-发布”模式，而Vue的实例正好实现了这一模式，所以我们只需要创建另一个Vue实例就可以实现event-bus了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.$bus.$on(eventname,(data)=&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(eventname,data);</span><br></pre></td></tr></table></figure><p><a name="3dc6070a"></a></p><h2 id="最后要说的"><a href="#最后要说的" class="headerlink" title="最后要说的"></a>最后要说的</h2><p>Vue组件之间通信出了以上列举的方法还可以使用Vuex。Vuex是官方提供的一个通用状态管理器。在中大型项目中，如果在组件间任意传递数据会导致应用的数据混乱并且难以管理，而Vuex提供了单向数据流绑定，应用中的每一个状态都可以存储到Vuex中进行统一管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://get.pxhere.com/photo/photography-wallpaper-portrait-landscape-cute-lovely-happy-alive-natural-beautiful-beauty-live-hair-green-girl-hairstyle-black-hair-long-hair-hair-coloring-brown-hair-1452521.jpg&quot; alt=&quot;Vue dispatch、broaddcast、event-bus实现&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Typescript学习-接口</title>
    <link href="http://yoursite.com/2019/03/31/ts-%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/03/31/ts-接口/</id>
    <published>2019-03-31T13:16:38.000Z</published>
    <updated>2021-01-02T10:50:07.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.rawpixel.com/s3fs-private/rawpixel_images/website_content/k-63-dsc055535259-coke_1.jpg?auto=format&amp;bg=F4F4F3&amp;con=3&amp;cs=srgb&amp;dpr=1&amp;fm=jpg&amp;ixlib=php-1.1.0&amp;mark=rawpixel-watermark.png&amp;markalpha=90&amp;markpad=13&amp;markscale=10&amp;markx=25&amp;q=75&amp;usm=15&amp;vib=3&amp;w=1600&amp;s=3799e16babbb570d2b18315e1a5710e9" alt=""><br><a id="more"></a></p><p><a name="61a3ec66"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TypeScript的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure><p><a name="c2a37b74"></a></p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123;color: <span class="built_in">string</span>; area: <span class="built_in">number</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;color: <span class="string">"white"</span>, area: <span class="number">100</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">"black"</span>&#125;);</span><br></pre></td></tr></table></figure><p><a name="c17fa77c"></a></p><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    readonly x: <span class="built_in">number</span>;</span><br><span class="line">    readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用<code>const</code>，若做为属性则使用<code>readonly</code>。<br><br><br>索引签名<br><br><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="25009be8"></a></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。<br>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISearchFunc &#123;</span><br><span class="line">(source:<span class="built_in">string</span>):<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> search:ISearchFunc = (source):<span class="function"><span class="params">void</span>=&gt;</span> &#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="194da868"></a></p><h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">[index:<span class="built_in">number</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray:StringArray = [</span><br><span class="line"><span class="string">"Jack"</span>,</span><br><span class="line">  <span class="string">"Sam"</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> str1 = myArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Anim &#123;</span><br><span class="line">name:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Anim &#123;</span><br><span class="line">breed:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="c8c05a8b"></a></p><h2 id="类接口"><a href="#类接口" class="headerlink" title="类接口"></a>类接口</h2><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 <br><br><br>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。<br>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， <code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    tick();</span><br><span class="line">&#125;ty</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure></p><p><a name="86e26f66"></a></p><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以继承。这让我们可以轻松的将一个接口中的属性复制到另一个接口中，可以更灵活的将可以重用的属性独立出来。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure></p><p><a name="e076dbf6"></a></p><h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    interval: <span class="built_in">number</span>;</span><br><span class="line">    reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><p><a name="a16ad588"></a></p><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。<br>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Location &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.rawpixel.com/s3fs-private/rawpixel_images/website_content/k-63-dsc055535259-coke_1.jpg?auto=format&amp;amp;bg=F4F4F3&amp;amp;con=3&amp;amp;cs=srgb&amp;amp;dpr=1&amp;amp;fm=jpg&amp;amp;ixlib=php-1.1.0&amp;amp;mark=rawpixel-watermark.png&amp;amp;markalpha=90&amp;amp;markpad=13&amp;amp;markscale=10&amp;amp;markx=25&amp;amp;q=75&amp;amp;usm=15&amp;amp;vib=3&amp;amp;w=1600&amp;amp;s=3799e16babbb570d2b18315e1a5710e9&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Typescript学习计划" scheme="http://yoursite.com/categories/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="Typescript" scheme="http://yoursite.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript学习-基本类型</title>
    <link href="http://yoursite.com/2019/03/31/ts-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/31/ts-基本类型/</id>
    <published>2019-03-31T13:16:26.000Z</published>
    <updated>2021-01-02T10:50:07.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.rawpixel.com/s3fs-private/rawpixel_images/website_content/k-s7-jg-004aaa.jpg?auto=format&amp;bg=F4F4F3&amp;con=3&amp;cs=srgb&amp;dpr=1&amp;fm=jpg&amp;ixlib=php-1.1.0&amp;mark=rawpixel-watermark.png&amp;markalpha=90&amp;markpad=13&amp;markscale=10&amp;markx=25&amp;q=75&amp;usm=15&amp;vib=3&amp;w=1600&amp;s=6c8c046e0b837035b4cbee8f277d62e6" alt=""><br><a id="more"></a><br><a name="06e1ad91"></a></p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>表示逻辑真或假</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone:<span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><a name="55d4790c"></a></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>表示数字类型，支持十进制、八进制、十六进制</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><p><a name="cc4dd1da"></a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>表示字符串类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure><p><a name="0e67d4b0"></a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>表示数组类型，有两种方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:<span class="built_in">string</span>[] = [<span class="string">'12'</span>,<span class="string">'23'</span>]</span><br></pre></td></tr></table></figure><p><a name="bd18cb09"></a></p><h2 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, 'number' does not have 'substr'</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><p><a name="56975625"></a></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red,Yellow,Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c:Color = Color.Red;</span><br></pre></td></tr></table></figure><p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="comment">//////////</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green=<span class="number">2</span>, Blue=<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到 Color里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorName);  <span class="comment">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure><p><a name="Any"></a></p><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。<br><a name="Void"></a></p><h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>某种程度上来说，void 类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。<br>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予undefined 和 null：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p><a name="57701822"></a></p><h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h2><p>TypeScript 里 undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大<br>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。<br>然而，当你指定了 – strictNullChecks标记，null 和 undefined 只能赋值给<code>void</code>和它们各自。 这能避免 _很多_常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined ，你可以使用联合类型 string|null|undefined。 </p><blockquote><p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p></blockquote><p><a name="Never"></a></p><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。<br><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使 <code>any</code>也不可以赋值给<code>never</code>。<br><a name="Ojbect"></a></p><h2 id="Ojbect"><a href="#Ojbect" class="headerlink" title="Ojbect"></a>Ojbect</h2><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。<br>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create(&#123; prop: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line">create(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="string">"string"</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><a name="9650a3c5"></a></p><h2 id="类型和断言"><a href="#类型和断言" class="headerlink" title="类型和断言"></a>类型和断言</h2><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。<br>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。<br>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><p>另一个为<code>as</code>语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.rawpixel.com/s3fs-private/rawpixel_images/website_content/k-s7-jg-004aaa.jpg?auto=format&amp;amp;bg=F4F4F3&amp;amp;con=3&amp;amp;cs=srgb&amp;amp;dpr=1&amp;amp;fm=jpg&amp;amp;ixlib=php-1.1.0&amp;amp;mark=rawpixel-watermark.png&amp;amp;markalpha=90&amp;amp;markpad=13&amp;amp;markscale=10&amp;amp;markx=25&amp;amp;q=75&amp;amp;usm=15&amp;amp;vib=3&amp;amp;w=1600&amp;amp;s=6c8c046e0b837035b4cbee8f277d62e6&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Typescript学习计划" scheme="http://yoursite.com/categories/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="Typescript" scheme="http://yoursite.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>手写一个Promise</title>
    <link href="http://yoursite.com/2019/03/31/promise/"/>
    <id>http://yoursite.com/2019/03/31/promise/</id>
    <published>2019-03-31T12:47:03.000Z</published>
    <updated>2021-01-02T10:50:07.333Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/2061057/pexels-photo-2061057.jpeg?cs=srgb&amp;dl=adorable-animal-bed-2061057.jpg&amp;fm=jpg" alt=""><br><a id="more"></a></p><p><a name="df45c20f"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Promise是为了解决Javascript回调嵌套过多导致回调地狱（callbackhell）而产生的。目前已被纳入了es2015规范，主流浏览器都支持Promise。为了在工作中更好的运用Promise,我们需要理解Promise规范与内部实现机制，下面我们来手动实现一个Promise。</p><p><a name="2d7cd21f"></a></p><h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+规范"></a>Promise/A+规范</h2><p>在写代码之前让我们先了解下 Promise/A+规范。<br>一个promise有三种状态：</p><ul><li>pending:表示初始状态，可以转移到 fullfilled 或者 rejected 状态</li><li>fulfilled:表示操作成功，不可转移状态</li><li>rejected:表示操作失败，不可转移状态</li><li>必须有一个 then 异步执行方法，then 接受两个参数且必须返回一个promise：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1553841212355-dc481bad-250e-4b16-9207-a221230c6fba.png#align=left&amp;display=inline&amp;height=277&amp;originHeight=297&amp;originWidth=801&amp;size=0&amp;status=done&amp;width=746" alt=""></p><p>借用这张来自MDN的流程图我们可以清晰的看到 Promise 状态的流转过程。</p><p><a name="7920d5ef"></a></p><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><p>下面我们来实现一个简单版的 Promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise1</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">self.status = <span class="string">'pending'</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.reason = <span class="literal">undefined</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(self.status===<span class="string">'pending'</span>)&#123;</span><br><span class="line">    self.status = <span class="string">'fullfilled'</span>;</span><br><span class="line">      self.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(self.status===<span class="string">'pending'</span>) &#123;</span><br><span class="line">    self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      self.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">  executor(resolve,reject);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise1.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled,onRejected</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'fullfilled'</span>) &#123;</span><br><span class="line">  onFullfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'rejected'</span>) &#123;</span><br><span class="line">  onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> p= <span class="keyword">new</span> Promise1(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;resolve(<span class="number">1</span>)&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;)</span><br><span class="line"><span class="comment">//输出1</span></span><br></pre></td></tr></table></figure><p><a name="8a03c7d9"></a></p><h2 id="支持异步"><a href="#支持异步" class="headerlink" title="支持异步"></a>支持异步</h2><p>现在，我们实现了最简单的 Promise。以上版本的Promise是存在很多问题的。为什么呢？最大的问题是它不支持异步，然而在现实中，Promise绝大多数使用场景都是异步。让我们来为 Promise 加入异步功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fullfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise1</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">self.status = PENDING;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.reason = <span class="literal">undefined</span>;</span><br><span class="line">  self.fullfilledCallbacks = [];</span><br><span class="line">  self.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    value.then(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status===PENDING)&#123;</span><br><span class="line">        self.status = FULFILLED;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.fullfilledCallbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">        cb(self.value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status===PENDING) &#123;</span><br><span class="line">        self.status = REJECTED;</span><br><span class="line">        self.reason = reason;</span><br><span class="line">        self.rejectedCallbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">        cb(self.reason);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">  executor(resolve,reject);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise1.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled,onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise1(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _value = (<span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; onFulfilled(value)) || value;</span><br><span class="line">        resolve(_value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _reason = (<span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> &amp;&amp; onRejected(reason)) || reason;</span><br><span class="line">        reject(_reason);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status==PENDING) &#123;</span><br><span class="line">      self.fullfilledCallbacks.push(success);</span><br><span class="line">        self.rejectedCallbacks.push(error);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(self.status==FULLFILLED)&#123;</span><br><span class="line">      success.call(<span class="keyword">this</span>,<span class="keyword">this</span>.value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(self.status==REJECTED) &#123;</span><br><span class="line">      error.call(<span class="keyword">this</span>,<span class="keyword">this</span>.reason);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，我们做了如下更改：</p><ol><li>将 Promise 三个状态定义为常量，方便维护</li><li>对于 Promise resolve和reject 函数执行加入异步处理</li><li>在Promise.then中返回新的Promise对象，使Promise可以支持链式调用</li></ol><p><a name="852384c0"></a></p><h2 id="错误处理以及静态方法"><a href="#错误处理以及静态方法" class="headerlink" title="错误处理以及静态方法"></a>错误处理以及静态方法</h2><p>下面让我们来为Promise 添加错误处理以及静态方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误处理</span></span><br><span class="line">Promise1.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回fullfilled Promise对象</span></span><br><span class="line">Promise1.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise1(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 rejected Promise 对象</span></span><br><span class="line">Promise1.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise1(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise.all方法</span></span><br><span class="line">Promise1.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">length, resolve</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> values = [];</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">i, value</span>) </span>&#123;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">if</span> (++count === length) &#123;</span><br><span class="line">                resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise1(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> done = gen(promises.length, resolve);</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                done(index, value)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise.race方法</span></span><br><span class="line">Promise1.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise1(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">           promise.then(resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个问题，就是在当我们console.log(Promise1.resolve(‘a’))的时候，我发现打印出来的状态竟然是 pending状态，我猜想原因是应该是resolve中函数异步执行，在当我们console的时候setTimeout中代码未执行，所以我给出的解决方法是将状态变化与赋值移到setTimeout外面，这样就不会产生刚才的问题了，更改后代码长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    value.then(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line">  self.status = FULFILLED;</span><br><span class="line">  self.value = value;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status===PENDING)&#123;</span><br><span class="line">        self.fullfilledCallbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">        cb(self.value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    self.status = REJECTED;</span><br><span class="line">    self.reason = reason;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status===PENDING) &#123;</span><br><span class="line">        self.rejectedCallbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">        cb(self.reason);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="25f9c7fa"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上实践，我们成功的手写了一个功能完备的 Promise。这里给我的最大启发是如果我们想学习一个东西，必须深入到它的底层，了解它的运行原理与具体实现方法，并且可以造一个简单的轮子，这样才算我们掌握了该知识点。从前的我对于这一点没有关注的太多，导致在用某个知识点时只是掌握的它的表层用法，在高级一点的使用场景时完全不会运用。以后我会更加注重源码方面的学习，弥补我这方面的不足。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/2061057/pexels-photo-2061057.jpeg?cs=srgb&amp;amp;dl=adorable-animal-bed-2061057.jpg&amp;amp;fm=jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>为什么要代码审查</title>
    <link href="http://yoursite.com/2019/03/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/03/10/为什么要做代码审查/</id>
    <published>2019-03-10T14:56:44.000Z</published>
    <updated>2021-01-02T10:50:07.335Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/2058172/pexels-photo-2058172.jpeg?cs=srgb&amp;dl=architectural-design-architecture-building-2058172.jpg&amp;fm=jpg" alt=""><br><a id="more"></a></p><blockquote><p>原文地址：<a href="http://sophiebits.com/2018/12/25/why-review-code.html" target="_blank" rel="noopener">http://sophiebits.com/2018/12/25/why-review-code.html</a><br>作者：Sophie Alpert<br>发布时间：2018年12月25日</p></blockquote><p>最近一个朋友问我为什么代码审查很有价值？至少大多数硅谷科技公司在每一次变化时都做代码审查，以获得至少两双眼睛去监控代码变化。在我以前的工作，我们在一段时间（很短）选择了做代码审查，然后一个来自 Google 的雇员加入了我们并且激励我们审查我们所有的代码。这是一个很好的建议。</p><p>如果您做的正确，代码审查不会感到繁重。您和您的审查者不是对手；您们一起工作来构建最好的软件。重要是不要采用反馈-即使您的代码需要改变，这并不意味着您是有问题的。得到反馈是正常的，并且这会帮助您成长！</p><p>有些公司有着复杂的规则关于多少人必须审查每一份代码，严格规定每一部分代码的责任人。我认为那完全没有必要；我更倾向于一个仅仅规定每一部分代码必须有人去审查的简单的系统。在实践中，您仍然会将评论发送给相应的代码责任人，但是好的地方在于它没有硬性要求。</p><p>这是我认为审查代码是有价值的最大的几点原因。</p><ol><li><p>从代码本身来看，代码审查最明显的价值往往是“发现错误”。或者如果您再看的长远些，在那些作者不知道的最佳实践或者潜在规则的情况下，代码审查者可以通过反馈来帮助实际的代码变得更好。</p></li><li><p>宏观层面上的知识共享。当您审查其他人代码时，您往往会学到新技术，这会使您未来收益-反之亦然，如果在您的代码被审查时某个人建议一种更好的方法去做一些事。如果您可以把您学到的东西在未来使用，您将成长为一名工程师。</p></li><li><p>微观层面上的知识共享。通过增加那些熟悉任何代码的人员来减轻<a href="https://en.wikipedia.org/wiki/Bus_factor" target="_blank" rel="noopener">“总线因素”</a>。</p></li><li><p>共享正确的方向。其次，代码审查迫使您与队友沟通您在做的事情，这有助于确保您在短时间内不会走向错误的方向，从而给他们回退代码的机会。</p></li><li><p>沟通练习。无论是在团队内或者团队外，清晰的沟通是成功工作最重要的技能之一！代码审查给您一个机会在无论是在描述更改的目的或者给一个反馈时去练习清晰的写作。</p></li><li><p>历史记录。根据我的经验，当人们知道有人在阅读信息时，他们往往会写的更好。当回顾旧的更改记录时这通常是有用的。</p></li><li><p>关于要讨论的东西。当您试图同意做什么改变，有时候很难口头描述和同意的具体细节或者一个特定的算法，通过一段代码描述可以更加精确。因为代码往往是明确的。</p></li><li><p>团队凝聚力。当您定期做代码审查时，工作感觉有点像一个单一的团队一起工作，而不是每个人在自己的轨道上运行。</p></li><li><p>阅读练习。练习阅读别人的代码可以帮助您记住如何使自己的代码更加具有可读性（可维护性）。这将会使好的代码在以后永远持续下去！我认为2，5，6三个原因是最有价值的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/2058172/pexels-photo-2058172.jpeg?cs=srgb&amp;amp;dl=architectural-design-architecture-building-2058172.jpg&amp;amp;fm=jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译计划" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="代码审查" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Javascript排序算法</title>
    <link href="http://yoursite.com/2019/03/05/Javascript%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/05/Javascript排序算法/</id>
    <published>2019-03-05T14:50:06.000Z</published>
    <updated>2021-01-02T10:50:07.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/205316/pexels-photo-205316.png?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940" alt=""><br><a id="more"></a><br><a name="34fe9f5c"></a></p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>排序是我们日常开发中非常常用的一种操作。目前最经典的排序算法有十种，分别是：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序。下面我们介绍两种最常用的排序算法：冒泡排序和快速排序。</p><p><a name="5d7ecc89"></a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序实现思想比较简单，但是性能较差，适合作为培训教学使用。主要实现思想是：遍历数据中每一个节点，如果不合符我们预期的顺序则和下一个数据交换位置，依此类推。<br><br><img src="https://cdn.nlark.com/yuque/0/2019/gif/149846/1551170760364-233f98f8-4890-432b-9603-9a9876e86283.gif#align=left&amp;display=inline&amp;height=232&amp;originHeight=257&amp;originWidth=826&amp;size=0&amp;status=done&amp;width=746" alt=""><br><br>实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,n,n1</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> temp = arr[n];</span><br><span class="line">arr[n] = arr[n1];</span><br><span class="line">arr[n1] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[i]) &#123;</span><br><span class="line">                swap(arr,j,i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="5ee213ee"></a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是已知排序算法中最快的之一，适合数据量较大的时候使用。其主要实现思想是：先取一个基数（一般取数据的中间位置），然后对基数两边的数据分别排序，比基数大的放右边，比基数小的放左边。之后，对左右两边的数据进行以上相同的操作，直到左右两边数据为空。<br><br><img src="https://cdn.nlark.com/yuque/0/2019/gif/149846/1551170760350-1d8e709f-2266-456d-967a-25ba1682e275.gif#align=left&amp;display=inline&amp;height=232&amp;originHeight=252&amp;originWidth=811&amp;size=0&amp;status=done&amp;width=746" alt=""><br><br>实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> piovtIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"><span class="keyword">let</span> piovt = arr.splice(piovtIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> _left = []</span><br><span class="line"><span class="keyword">let</span> _right = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> item = arr[i];</span><br><span class="line"><span class="keyword">if</span>(item&lt;piovt) &#123;</span><br><span class="line">_left.push(item)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_right.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> quickSort(_left).concat([piovt],quickSort(_right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="25f9c7fa"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1551170760356-3d45ea06-0a88-4fb5-9dfb-f091019e8db4.png#align=left&amp;display=inline&amp;height=504&amp;originHeight=1272&amp;originWidth=1882&amp;size=0&amp;status=done&amp;width=746" alt=""><br><br>不难看出：两种算法相对比之下，快速排序的所用的操作更少。下面我们用一个例子来验证下这个结论：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++) &#123;</span><br><span class="line">_arr.push(<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(_arr)</span></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> piovtIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"><span class="keyword">let</span> piovt = arr.splice(piovtIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> _left = []</span><br><span class="line"><span class="keyword">let</span> _right = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> item = arr[i];</span><br><span class="line"><span class="keyword">if</span>(item&lt;piovt) &#123;</span><br><span class="line">_left.push(item)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_right.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> quickSort(_left).concat([piovt],quickSort(_right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,n,n1</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> temp = arr[n];</span><br><span class="line">arr[n] = arr[n1];</span><br><span class="line">arr[n1] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[i]) &#123;</span><br><span class="line">                swap(arr,j,i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> time1 = <span class="built_in">Date</span>.now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = bubbleSort(_arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(a)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡排序用时：'</span>,<span class="built_in">Date</span>.now()-time1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> time2 = <span class="built_in">Date</span>.now()</span><br><span class="line">quickSort(_arr)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'快速排序用时：'</span>,<span class="built_in">Date</span>.now()-time2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序用时： 5373</span></span><br><span class="line"><span class="comment">// 快速排序用时： 533</span></span><br></pre></td></tr></table></figure><p>在数据量为10w时，结果输出为冒泡排序用时5373ms,快速排序用时533ms，两者性能相差10倍之多！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/205316/pexels-photo-205316.png?auto=compress&amp;amp;cs=tinysrgb&amp;amp;dpr=2&amp;amp;h=650&amp;amp;w=940&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Express中的服务端缓存</title>
    <link href="http://yoursite.com/2019/02/28/express-cache/"/>
    <id>http://yoursite.com/2019/02/28/express-cache/</id>
    <published>2019-02-28T12:50:18.000Z</published>
    <updated>2021-01-02T10:50:07.332Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/238118/pexels-photo-238118.jpeg?cs=srgb&amp;dl=computer-desk-electronics-238118.jpg&amp;fm=jpg" alt=""><br><a id="more"></a></p><blockquote><p>原文地址：<a href="https://blog.bitsrc.io/server-side-caching-in-expressjs-24038daec102" target="_blank" rel="noopener">https://blog.bitsrc.io/server-side-caching-in-expressjs-24038daec102</a><br>作者：Chidume Nnamdi</p></blockquote><p>缓存已经是在软件开发过程中被广泛应用的技巧之一。在这篇文章中，我们将看看如何在 express 服务端启用缓存。</p><h2 id="服务端缓存-基本理念"><a href="#服务端缓存-基本理念" class="headerlink" title="服务端缓存-基本理念"></a>服务端缓存-基本理念</h2><p>Web 应用通常在服务端获取新数据然后在 DOM 中渲染。这给服务器带来了大量的负担，因为它需要大量的处理能力取产生动态数据。浏览器端利用缓存来防止频繁的请求。浏览器有内部缓存机制来允许在相同的请求发生时存储请求的响应并且用缓存的响应数据来响应请求。这有助于防止来自相同请求的频繁服务器操作。</p><p>虽然浏览器有帮助，但是服务器需要为不同的浏览器和用户运行和渲染。服务器端必须找到一种优化长操作的方法。这已经可以通过运用缓存来做到了。</p><h2 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h2><p>在我们开始探究服务器缓存之前先让我们明白什么是缓存？<br>缓存的概念是存储 CPU 密集型操作的结果，以便在下次执行具有相同输入同样的操作时，结果从储存中返回而不是重新执行消耗资源的操作。<br>在编程中，函数通常被缓存，这个过程称为记忆化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longOp</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// simulating a long operation using setTimeout</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'done with longOp func'</span>)</span><br><span class="line">        result = <span class="number">90</span> * input</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">longOp(<span class="number">5</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">50</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">500</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">5000</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line"><span class="comment">// Total ms to run: 4000 ms!</span></span><br><span class="line">longOp(<span class="number">5</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">50</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">500</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">5000</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line"><span class="comment">// Total ms to run: 4000 ms! again</span></span><br></pre></td></tr></table></figure></p><p>以上函数运行花了1000ms,我们试着用不同的输入调用它：5,50,500,5000。我们的文件总共花了4000ms去运行。再次运行相同的输入将同样需要4000ms。<br>现在，因为我们知道输出依赖输入 return input*90。我们可以储存每一次输入产生的结果，并且在下一次同样输入调用时返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longOp</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result  = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(cache[input]) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[input];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            result = input * <span class="number">90</span>;</span><br><span class="line">            cache[input] = result;</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在 loogOp 函数中加入了缓存。缓存对象是我们为每一次输入储存计算结果的地方。当函数被调用，我们检查缓存对象中是否有结果，如果有我们将跳过一个长操作并返回结果，如果没有，我们执行长操作并将结果存到缓存中，用输入作为 key 值，这样在下一次同样输入的函数调用中，我们可以在缓存中找到相应结果并返回。<br>如果我们再次运行loogOp：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">longOp(<span class="number">5</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">50</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">500</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line">longOp(<span class="number">5000</span>) <span class="comment">// takes 1000 ms to complete</span></span><br><span class="line"><span class="comment">// Total ms to run: 4000 ms!</span></span><br><span class="line">longOp(<span class="number">5</span>) <span class="comment">// takes 1 ms to complete</span></span><br><span class="line">longOp(<span class="number">50</span>) <span class="comment">// takes 1 ms to complete</span></span><br><span class="line">longOp(<span class="number">500</span>) <span class="comment">// takes 1 ms to complete</span></span><br><span class="line">longOp(<span class="number">5000</span>) <span class="comment">// takes 1 ms to complete</span></span><br><span class="line"><span class="comment">// Total ms to run: 4 ms! again :)</span></span><br></pre></td></tr></table></figure></p><p>您看，这是一个巨大的性能提升。从4000ms到4ms,第一次运行没有缓存，第二次运行仅仅从缓存中返回了第一次运行的结果。<br>现在，我们已经明白了缓存的意义，让我们继续。</p><blockquote><p>Tips:用<a href="https://github.com/teambit/bit" target="_blank" rel="noopener">Bit</a> 在项目之间共享组件，并且可以更快的构建JS应用。这是从repo共享包并且使用他们的最快的方法。<br><img src="https://cdn-images-1.medium.com/max/1600/1*Yhkh7jbS5Mx9uP96Y88pZg.gif" alt=""></p></blockquote><p>我们经历了相同的事情，当我们在用 express.js :一个快速搭建服务的 Node.js 框架。假设我们有一个像这样的索引路径：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// simulating a long process</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        res.send(<span class="string">'message from route /'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们在这里有一个路由，它将会返回 <code>message from route /</code>消息，我们使用setTimeout模拟一个缓慢的进程。这就好比如果我们是一个新闻网站服务器API，我们生成近千条新闻。这将花费近1000ms来为我们的用户交付新闻负载。<br>来试试这个，新建一个 Node 项目并且安装 express 模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir expr-cache-prj</span><br><span class="line">cd expr-cache-prj</span><br><span class="line">npm init -y</span><br><span class="line">npm i express</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure></p><p>将下面的内容粘贴到 index.js 文件中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir expr-cache-prj</span><br><span class="line"><span class="built_in">cd</span> expr-cache-prj</span><br><span class="line">npm init -y</span><br><span class="line">npm i express</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure></p><p>在命令行中运行<code>node ./</code>来启动服务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node ./</span><br><span class="line">server:3000</span><br></pre></td></tr></table></figure></p><p>打开您最喜爱的浏览器并导航到<code>localhost:3000</code>。打开开发者工具并切换到 Network 面板。</p><p><img src="https://cdn-images-1.medium.com/max/2600/1*g2IiQF7E5wUiR-boTdbebw.png" alt=""></p><p>您可以在 timeline 面板中看到渲染路由大约花费了1090ms,因为1000ms 花在了服务响应，剩下的90m花在了将  message 内容渲染。您了解服务器如何影响我们 Web 应用的性能。优化不仅仅是在客户端的，服务器的优化更为重要。如果您的服务器端应用需要1000毫秒来发送客户端将采用的数据（1000 + 0.000001）1000.000001毫秒进行渲染，那么优化客户端甚至可以达到0.000001毫秒。</p><p>如果我们将时间增加到9000ms:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// simulating a long process</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        res.send(<span class="string">'message from route /'</span>)</span><br><span class="line">    &#125;, <span class="number">9000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2600/1*UJ5Mk5V_VBFd-ljLPi8Clw.png" alt=""></p><p>在这里消息渲染花费了9074ms,在这9074ms中，服务器发送消息花费了9000ms。</p><p>现在让我们看看使用缓存的 express 的不同技术：</p><h2 id="使用自定义缓存技术"><a href="#使用自定义缓存技术" class="headerlink" title="使用自定义缓存技术"></a>使用自定义缓存技术</h2><p>在 express 中，中间件是添加缓存的理想方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middleWare1 = <span class="function">(<span class="params">req,res,next</span>)=&gt;</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> middleWare2 = <span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">app.get(route,middleWare1,middleWare2)</span><br></pre></td></tr></table></figure><p>当路由被访问时，express 调用middleWare1，middleWare1 调用next ，express 调用下一个中间件 middleWare2，middleWare2 调用 next，然后因为没有更多的中间件内联执行退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">expressjs</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">route match</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">middleWare1</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">middleWare2</span><br></pre></td></tr></table></figure><p>一般来说，我们在最后一个中间件里将数据发送给用户。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middleWare1 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> middleWare2 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">'expressjs data'</span>)</span><br><span class="line">&#125;</span><br><span class="line">app.get(route, middleWare1, middleWare2)</span><br></pre></td></tr></table></figure></p><p>如果我们在 middleWare1 中添加中间件，我们会看到完美的配合。它将会首先运行，所以我们要检查路由是否被缓存。如果是，我们会从 middleWare1 发送缓存结果，如果不是，我们将冒泡到 middleWare2.<br>在我们 <code>/</code>路由中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// simulating a long process</span></span><br><span class="line">    wait(<span class="number">1000</span>)</span><br><span class="line">    res.send(<span class="string">'message from route /'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们将添加一个中间件来保存我们的缓存代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> middware = <span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = req.url;</span><br><span class="line">    <span class="keyword">if</span>(cache[key]) &#123;</span><br><span class="line">        res.send(<span class="string">'from cache'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.sendResponse = res.send;</span><br><span class="line">        res.send = <span class="function">(<span class="params">body</span>)=&gt;</span>&#123;</span><br><span class="line">            cache[key] = body;</span><br><span class="line">            res.sendResponse(body);</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.get(<span class="string">'/'</span>,middleware,(req,res)=&gt;&#123;</span><br><span class="line">    wait(<span class="number">1000</span>);</span><br><span class="line">    res.send(<span class="string">'message from route /'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们创建了中间件 middleware。我们创建了存放缓存结果的对象。在 middleware 函数中，我们用请求的路径作为键。首先我们检查基于请求的路径的 key 在缓存对象中是否存在。如果是，我们发送从缓存中发送响应，如果没有，我们在缓存对象中储存请求体并且发送响应以便下一次请求可以直接提取缓存数据。</p><p>如果我们在服务端运行以上代码，我们将在浏览器中看到改进：</p><p><img src="https://cdn-images-1.medium.com/max/2600/1*OdfINqOXN690s6_Meea5Tg.png" alt=""></p><p>看到了没，浏览器花了23ms来渲染。是我们上一次的一半多。<br>我们已经明白来怎么在 express 服务中添加缓存。我们上面做的有以下缺点：</p><ol><li>我们将缓存存储在进程中，一旦我们的服务挂掉，我们将从头开始缓存。</li><li>缓存不能在同一进程中多数服务中共享。</li></ol><p>NB 缓存在get类型路由是可行的，但是不能用在 put,delete,post 路由中。当输出依赖与输入时，在get路由才能添加缓存。get路由副作用永远不应该被缓存，因为输出会随着时间而变化。</p><h2 id="采用Redis"><a href="#采用Redis" class="headerlink" title="采用Redis"></a>采用Redis</h2><p><em>Redis是一个非传统数据库，被称为数据结构服务器。它可以在内存中以极快的速度运行。</em><br>Redis 在内存存储数据方面非常强大，我们可以在我们的应用中用它做数据缓存或者数据库。它主要的AIP由<code>set(key,value)</code>和<code>get(key)</code>组成。为了在我们已有的应用中整合 Redis，我们开始安装Redis模块。<br>首先，我们安装Redis npm 模块：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redis</span><br></pre></td></tr></table></figure></p><p>现在，我们创建了一个 Redis 模块并且和 Redis 服务建立了🔗。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="keyword">const</span> client = redis.createClient()</span><br></pre></td></tr></table></figure></p><p>我们像这样编辑 exp.js：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="keyword">const</span> client = redis.createClient()</span><br><span class="line">client.on(<span class="string">'connect'</span>,()=&gt;&#123;</span><br><span class="line">    log(<span class="string">'redis connected'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">var</span> midWare = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = req.url</span><br><span class="line">    client.get(key, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="literal">null</span> &amp;&amp; result != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.send(<span class="string">'from cache'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.sendResponse = res.send</span><br><span class="line">            res.send = <span class="function">(<span class="params">body</span>) =&gt;</span> &#123;</span><br><span class="line">                client.set(key, body, (err, reply) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reply == <span class="string">'OK'</span>)</span><br><span class="line">                        res.sendResponse(body)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.get(<span class="string">'/'</span>, midWare, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// simulating a long process</span></span><br><span class="line">    wait(<span class="number">1000</span>)</span><br><span class="line">    res.send(<span class="string">'message from route /'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>和上面的代码一样，我们只是改为用 Redis 替代。<code>client.get(key,cb)</code>参考传入的密钥从存储中检索储存的值。</p><h2 id="采用Memcached"><a href="#采用Memcached" class="headerlink" title="采用Memcached"></a>采用Memcached</h2><p>使用Memcached，我们将安装 memjs npm 模块：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i memjs</span><br></pre></td></tr></table></figure></p><p>并在我们的exp.js中配置它:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memjs = <span class="built_in">require</span>(<span class="string">'memjs'</span>)</span><br><span class="line"><span class="keyword">const</span> mc = memjs.Client.create()</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span></span><br><span class="line"><span class="keyword">var</span> midWare = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = req.url</span><br><span class="line">    mc.get(key, (err, val) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="literal">null</span> &amp;&amp; val != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.send(<span class="string">'from cache'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.sendResponse = res.send</span><br><span class="line">            res.send = <span class="function">(<span class="params">body</span>) =&gt;</span> &#123;</span><br><span class="line">                mc.set(key, body, &#123; <span class="attr">expires</span>: <span class="number">0</span> &#125;, (err, reply) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reply == <span class="string">'OK'</span>)</span><br><span class="line">                        res.sendResponse(body)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.get(<span class="string">'/'</span>, midWare, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// simulating a long process</span></span><br><span class="line">    wait(<span class="number">1000</span>)</span><br><span class="line">    res.send(<span class="string">'message from route /'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>与 Redis 相同，唯一改变的是客户端到 mc。 Redis 和 Memcached 具有几乎相同的 API，具有相同的功能。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们看到 expressjs 中的服务器端缓存是什么以及如何使用自定义代码配置一个。接下来，我们了解了如何使用 Redis 和 Memcached 将缓存添加到 expressjs 服务器。</p><p>缓存是我们加速应用程序尤其是服务器端应用程序的最佳优化技巧之一。许多人称它为不同的名称：memoization，这一切都归结为缓存的相同想法。</p><p>如果您对此或我应该添加、更正或删除的任何问题有任何疑问，请随时在下面发表评论并向我询问任何问题！谢谢 ！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/238118/pexels-photo-238118.jpeg?cs=srgb&amp;amp;dl=computer-desk-electronics-238118.jpg&amp;amp;fm=jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译计划" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="cache" scheme="http://yoursite.com/tags/cache/"/>
    
      <category term="server" scheme="http://yoursite.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>Javascript原型链</title>
    <link href="http://yoursite.com/2019/02/21/javascript/"/>
    <id>http://yoursite.com/2019/02/21/javascript/</id>
    <published>2019-02-21T14:08:51.000Z</published>
    <updated>2021-01-02T10:50:07.333Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1489875347897-49f64b51c1f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt=""><br><a id="more"></a></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在 Javascript 中我们可以使用构造函数来声明一个类，然后利用new关键词实例化类。在构造函数中，this指向来该构造函数本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">"Lily"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Lily</span></span><br><span class="line">person.move()</span><br></pre></td></tr></table></figure></p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>prototype 是一个对象，用于让所有的实例共享属性和方法。例如在上面的🌰中，我们在 Person 的prototype中添加了 move 方法，这样可以让所有的 Person 实例都继承这个方法。</p><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p><strong>proto</strong> 是各个浏览器厂商实现的非标准 Javascript 属性。它指向构造函数的 prototype 对象.例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span>js</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">"Lily"</span>)</span><br><span class="line">person.__proto__ === Person.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每一个构造函数的原型上面都会有 constructor 对象，它指向构造函数本身，用代码来表示就是这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">Person.prototype.constructor === Person</span><br></pre></td></tr></table></figure></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.name</span><br></pre></td></tr></table></figure><p>在 Javascript中，如果我们访问对象的某个属性，系统将先会在该对象上找，如果找不到，则会在该对象的<strong>proto</strong> 对象上继续找，如果没有会继续往上层找，即 Person.prototype.<strong>proto</strong>,直到最上层，系统会找到 Object.prototype,<br>Person.prototyoe.<strong>proto</strong> === Object.prototype,我们或许会问，Object.prototype.<strong>proto</strong> 又是什么呢？其实是 null 。这样就形成一条完整的原型链。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Javascript中最常用的继承方法就是原型链继承了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承多个父类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OtherSuperClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">    OtherClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">ChildClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype)</span><br><span class="line"><span class="built_in">Object</span>.assign(SuperClass.prototype,OtherSuperClass.prototype)</span><br><span class="line">ChildClass.prototype.constructor = ChildClass;</span><br></pre></td></tr></table></figure></p><p>相信你看完上面关于原型的介绍很快就会明白上面继承的原理：子类继承并且重写父类的方法和属性，而又不会影响父类。这里我们利用 Object.create 方法。</p><h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><p>我们通常使用 new 关键字实例化Javascript对象，在new的过程中其实发生了如下过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/**等同于*/</span></span><br><span class="line">person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.__proto__  = Person.protoype;</span><br><span class="line">Person.call(person)</span><br></pre></td></tr></table></figure></p><p>上面过程可以简单描述为，先创建一个 Object 实例，然后将该实例的 <strong>protot</strong> 属性指向Person.prototype ,最后再将 this 指针指向 Person，不是刚好符合我们上面所描述的那样吗？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Javascript 基于原型链的设计让我们使用起来非常方便，但是同时原型链对于 Javascript 初学者来说相对比较难以理解，在平常的工作和学些过程中，我们一定要牢固掌握基础知识，多多积累知识和经验，这样才能从容面对工作中遇到的难题。</p><!--## class在其它语言中，类通常是通过class关键词进行创建的。在ES6中，Javascript也增加类似的特性，可以通过class关键词来声明一个类。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    more() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'move'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Jack</span></span><br><span class="line">person.move()<span class="comment">//move</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我们利用class声明类一个Person类，并给Person中添加name属性和move方法。<br>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1489875347897-49f64b51c1f8?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1350&amp;amp;q=80&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="原型链" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>D3官方网站首页翻译</title>
    <link href="http://yoursite.com/2019/02/18/d3-translate/"/>
    <id>http://yoursite.com/2019/02/18/d3-translate/</id>
    <published>2019-02-18T15:05:02.000Z</published>
    <updated>2021-01-02T10:50:07.332Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://d3js.org.cn/home.png" alt=""><br><a id="more"></a><br><!--D3.js is a JavaScript library for manipulating documents based on data. D3 helps you bring data to life using HTML, SVG, and CSS. D3’s emphasis on web standards gives you the full capabilities of modern browsers without tying yourself to a proprietary framework, combining powerful visualization components and a data-driven approach to DOM manipulation.--></p><p>D3.js 是一个基于数据来操作文档的的 Javascript 库。D3 帮助您使用 HTML,SVG 和 CSS 来使数据栩栩如生。D3 在 web 标准上的重点在于不用自己私有的框架就可以给与你现代浏览器完整的结合了强大的 DOM 操作可视化组件和数据驱动方式的功能。</p><!--Download the latest version (5.9.1) here:--><p>最新版本（5.9.1）在这里下载：</p><ul><li><a href="https://github.com/d3/d3/releases/download/v5.9.1/d3.zip" target="_blank" rel="noopener">D3.zip</a></li></ul><!--To link directly to the latest release, copy this snippet:--><p>复制下面这段内容来直接链接到最新发布的版本：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><!--The full source and tests are also available for download on GitHub.--><p>完整的资源和测试也可以在 Github 上下载。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><!--Read more tutorials.--><!--D3 allows you to bind arbitrary data to a Document Object Model (DOM), and then apply data-driven transformations to the document. For example, you can use D3 to generate an HTML table from an array of numbers. Or, use the same data to create an interactive SVG bar chart with smooth transitions and interaction.--><p>D3 允许您绑定任意数据到 DOM 对象上，并且然后应用数据驱动转换到文档上。例如，您可以用 D3 从一个数组 生成一个 HTML 表格。或者用相同的数据创建栩栩如生的 SVG 柱状图。<a href="https://github.com/d3/d3/wiki/Tutorials" target="_blank" rel="noopener">阅读更多的教程</a></p><!--D3 is not a monolithic framework that seeks to provide every conceivable feature. Instead, D3 solves the crux of the problem: efficient manipulation of documents based on data. This avoids proprietary representation and affords extraordinary flexibility, exposing the full capabilities of web standards such as HTML, SVG, and CSS. With minimal overhead, D3 is extremely fast, supporting large datasets and dynamic behaviors for interaction and animation. D3’s functional style allows code reuse through a diverse collection of official and community-developed modules.--><p>D3不是一个单独力求提供所有可想到的功能的框架。相反，D3解决了问题的关键：基于数据高效的文档操作。这避免了专有的表示，并提供了非凡的灵活性，暴露了HTML，SVG和CSS等Web标准的全部功能。 D3 的开销极小，支持大型数据集和交互动画的动态行为。<br>D3 的函数式风格允许通过官方和各种社区开发的模块复用代码。</p><!--#Selections--><h1 id="选择集"><a href="#选择集" class="headerlink" title="选择集"></a>选择集</h1><!--Read more about selections.--><p>Modifying documents using the W3C DOM API is tedious: the method names are verbose, and the imperative approach requires manual iteration and bookkeeping of temporary state. For example, to change the text color of paragraph elements:</p><p>使用W3C DOM API修改文档非常繁琐：方法名称冗长，命令式方法需要手动迭代和临时状态缓存。例如，改变一个段落标签的字体颜色：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraphs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> paragraph = paragraphs.item(i);</span><br><span class="line">  paragraph.style.setProperty(<span class="string">"color"</span>, <span class="string">"white"</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><!--D3 employs a declarative approach, operating on arbitrary sets of nodes called selections. For example, you can rewrite the above loop as:--><p>D3采用声明式方法，运行在选中的任意节点上。例如，您可以将上面的循环重写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(<span class="string">"p"</span>).style(<span class="string">"color"</span>, <span class="string">"white"</span>);</span><br></pre></td></tr></table></figure><!--Yet, you can still manipulate individual nodes as needed:--><p>而且，您仍然可以根据需要操作单个节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">"body"</span>).style(<span class="string">"background-color"</span>, <span class="string">"black"</span>);</span><br></pre></td></tr></table></figure><!--Selectors are defined by the W3C Selectors API and supported natively by modern browsers. The above examples select nodes by tag name ("p" and "body", respectively). Elements may be selected using a variety of predicates, including containment, attribute values, class and ID.--><p>选择器由W3C Selectors API定义，并由现代浏览器原生支持。以上例子通过标签名称（p 和 body）获取节点。可以使用各种称谓来选择元素，比如属性，类名和 ID。</p><!--D3 provides numerous methods for mutating nodes: setting attributes or styles; registering event listeners; adding, removing or sorting nodes; and changing HTML or text content. These suffice for the vast majority of needs. Direct access to the underlying DOM is also possible, as each D3 selection is simply an array of nodes.--><p>D3 提供了许多改变节点的方法：设置属性或样式、注册事件监听器、添加，删除或者排序节点、改变 HTML 或者文字内容。这些可以满足绝大多数的需求。直接访问 DOM 底层也是可能的，因为每一个 D3 选择集合都是简单的原生节点数组。</p><!--#Dynamic Properties--><h1 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h1><!--Readers familiar with other DOM frameworks such as jQuery should immediately recognize similarities with D3. Yet styles, attributes, and other properties can be specified as functions of data in D3, not just simple constants. Despite their apparent simplicity, these functions can be surprisingly powerful; the d3.geoPath function, for example, projects geographic coordinates into SVG path data. D3 provides many built-in reusable functions and function factories, such as graphical primitives for area, line and pie charts.--><p>熟悉其他DOM框架（如jQuery）的读者应立即认识到与 D3 的相似之处。样式，属性和其他属性可以指定为D3中的数据函数，不仅仅是简单的常数。尽管它们显而易见，但这些功能可以令人惊讶地强大;例如，d3.geoPath 函数将地理坐标投影到SVG路径数据中。D3提供了许多内置的可重用函数和函数工厂，例如面积图，线图和饼图的图形基元。</p><!--For example, to randomly color paragraphs:--><p>例如，给段落标签设置随机颜色：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(<span class="string">"p"</span>).style(<span class="string">"color"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hsl("</span> + <span class="built_in">Math</span>.random() * <span class="number">360</span> + <span class="string">",100%,50%)"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><!--To alternate shades of gray for even and odd nodes:--><p>为偶数和奇数节点交替灰度阴影：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(<span class="string">"p"</span>).style(<span class="string">"color"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i % <span class="number">2</span> ? <span class="string">"#fff"</span> : <span class="string">"#eee"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><!--Computed properties often refer to bound data. Data is specified as an array of values, and each value is passed as the first argument (d) to selection functions. With the default join-by-index, the first element in the data array is passed to the first node in the selection, the second element to the second node, and so on. For example, if you bind an array of numbers to paragraph elements, you can use these numbers to compute dynamic font sizes:--><p>计算属性通常引用绑定数据。数据被指定为数值数组，并且每个值作为第一个参数（d）传递给选择函数。使用默认的join-by-index，数据数组中的第一个元素将传递给选择中的第一个节点，第二个元素传递给第二个节点，依此类推。例如，如果将数字数组绑定到段落元素，则可以使用这些数字来计算动态字体大小：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(<span class="string">"p"</span>)</span><br><span class="line">  .data([<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>])</span><br><span class="line">    .style(<span class="string">"font-size"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d + <span class="string">"px"</span>; &#125;);</span><br></pre></td></tr></table></figure><!--Once the data has been bound to the document, you can omit the data operator; D3 will retrieve the previously-bound data. This allows you to recompute properties without rebinding.--><p>一旦数据绑定到文档，您可以省略数据运算符; D3将检索先前绑定的数据。这允许您在不重新绑定的情况下重新计算属性。</p><h1 id="Enter-and-Exit"><a href="#Enter-and-Exit" class="headerlink" title="Enter and Exit"></a>Enter and Exit</h1><!--Using D3’s enter and exit selections, you can create new nodes for incoming data and remove outgoing nodes that are no longer needed.--><p>使用D3的 enter 和 exit ，您可以为传入数据创建新节点并删除不再需要的传出节点。</p><!--When data is bound to a selection, each element in the data array is paired with the corresponding node in the selection. If there are fewer nodes than data, the extra data elements form the enter selection, which you can instantiate by appending to the enter selection. For example:--><p>当数据被绑定到选择集中，在数据数组中的每一个元素与选择集中对应节点配对。如果节点数量少于数据，多余的 data 元素将会传入 enter 选择集, 您可以通过追加多余选择集来实例化。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">"body"</span>)</span><br><span class="line">  .selectAll(<span class="string">"p"</span>)</span><br><span class="line">  .data([<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>])</span><br><span class="line">  .enter().append(<span class="string">"p"</span>)</span><br><span class="line">    .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> <span class="string">"I’m number "</span> + d + <span class="string">"!"</span>; &#125;);</span><br></pre></td></tr></table></figure></p><!--Updating nodes are the default selection—the result of the data operator. Thus, if you forget about the enter and exit selections, you will automatically select only the elements for which there exists corresponding data. A common pattern is to break the initial selection into three parts: the updating nodes to modify, the entering nodes to add, and the exiting nodes to remove.--><p>更新节点是默认选择 - 数据运算符的结果。因此，如果您忘记了进入和退出选择，您将自动选择仅存在相应数据的元素。常见的模式是将初始选择分为三个部分：要修改的更新节点，要添加的进入节点以及要删除的现有节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update…</span></span><br><span class="line"><span class="keyword">var</span> p = d3.select(<span class="string">"body"</span>)</span><br><span class="line">  .selectAll(<span class="string">"p"</span>)</span><br><span class="line">  .data([<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>])</span><br><span class="line">    .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter…</span></span><br><span class="line">p.enter().append(<span class="string">"p"</span>)</span><br><span class="line">    .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exit…</span></span><br><span class="line">p.exit().remove();</span><br></pre></td></tr></table></figure></p><!--By handling these three cases separately, you specify precisely which operations run on which nodes. This improves performance and offers greater control over transitions. For example, with a bar chart you might initialize entering bars using the old scale, and then transition entering bars to the new scale along with the updating and exiting bars.--><p>通过分别处理这三种情况，可以精确指定在哪些节点上运行哪些操作。这可以提高性能并提供对转换的更好控制。例如，使用条形图，您可以使用旧比例初始化输入条形，然后将输入条形转换为新比例以及更新和退出条形。</p><!--D3 lets you transform documents based on data; this includes both creating and destroying elements. D3 allows you to change an existing document in response to user interaction, animation over time, or even asynchronous notification from a third-party. A hybrid approach is even possible, where the document is initially rendered on the server, and updated on the client via D3.--><p>D3允许您根据数据转换文档;这包括创建和销毁元素。D3允许您更改现有文档以响应用户交互，动画随时间推移，甚至来自第三方的异步通知。甚至可以采用混合方法，其中文档最初在服务器上呈现，并通过D3在客户端上更新。</p><!--#Transformation, not Representation--><h1 id="转换而非表现"><a href="#转换而非表现" class="headerlink" title="转换而非表现"></a>转换而非表现</h1><!--D3 does not introduce a new visual representation. Unlike Processing or Protovis, D3’s vocabulary of graphical marks comes directly from web standards: HTML, SVG, and CSS. For example, you can create SVG elements using D3 and style them with external stylesheets. You can use composite filter effects, dashed strokes and clipping. If browser vendors introduce new features tomorrow, you’ll be able to use them immediately—no toolkit update required. And, if you decide in the future to use a toolkit other than D3, you can take your knowledge of standards with you!--><p>D3没有引入新的视觉表现。与Processing或Protovis不同，D3的图形标记词汇直接来自Web标准：HTML，SVG和CSS。例如，您可以使用D3创建SVG元素，并使用外部样式表对其进行样式设置。您可以使用复合滤镜效果，虚线笔划和剪裁。如果浏览器厂商明天推出新功能，您将能够立即使用它们 - 无需更新工具包。而且，如果您决定将来使用 D3 以外的工具包，您可以随时使用你掌握的标准知识！</p><!--Best of all, D3 is easy to debug using the browser’s built-in element inspector: the nodes that you manipulate with D3 are exactly those that the browser understands natively.--><p>最重要的是，使用浏览器的内置元素检查器可以轻松调试D3：使用D3操作的节点正是浏览器本身可以理解的节点。</p><!--#Transitions--><h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><!--D3’s focus on transformation extends naturally to animated transitions. Transitions gradually interpolate styles and attributes over time. Tweening can be controlled via easing functions such as “elastic”, “cubic-in-out” and “linear”. D3’s interpolators support both primitives, such as numbers and numbers embedded within strings (font sizes, path data, etc.), and compound values. You can even extend D3’s interpolator registry to support complex properties and data structures.--><p>D3对转换的关注自然延伸到动画转换。随着时间的推移，过渡会逐渐插入样式和属性。可以通过 easeing 函数来控制动画效果 ，例如“elastic”，“cubic-in-out”和“linear”。D3的插值器支持两种基元，例如字符串中嵌入的数字和数字（字体大小，路径数据等）和复合值。您甚至可以扩展D3的插补器注册表以支持复杂的属性和数据结构。</p><!--For example, to fade the background of the page to black:--><p>例如，要将页面背景淡化为黑色：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">"body"</span>).transition()</span><br><span class="line">    .style(<span class="string">"background-color"</span>, <span class="string">"black"</span>);</span><br></pre></td></tr></table></figure></p><!--Or, to resize circles in a symbol map with a staggered delay:--><p>或者，使用交错延迟调整符号映射中的圆圈：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(<span class="string">"circle"</span>).transition()</span><br><span class="line">    .duration(<span class="number">750</span>)</span><br><span class="line">    .delay(<span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123; <span class="keyword">return</span> i * <span class="number">10</span>; &#125;)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(d * scale); &#125;);</span><br></pre></td></tr></table></figure></p><!--By modifying only the attributes that actually change, D3 reduces overhead and allows greater graphical complexity at high frame rates. D3 also allows sequencing of complex transitions via events. And, you can still use CSS3 transitions; D3 does not replace the browser’s toolbox, but exposes it in a way that is easier to use.--><p>通过仅修改实际更改的属性，D3可降低开销，并在高帧速率下实现更高的图形复杂性。D3还允许通过事件对复杂转换进行排序。并且，您仍然可以使用CSS3过渡; D3不会取代浏览器的工具箱，但会以更易于使用的方式公开它。</p><!--Want to learn more? Read these tutorials.--><p>想要学习更多教程请移步 <a href="https://github.com/d3/d3/wiki/Tutorials" target="_blank" rel="noopener">更多教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://d3js.org.cn/home.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译计划" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="D3" scheme="http://yoursite.com/tags/D3/"/>
    
      <category term="数据可视化" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL官方自述文件</title>
    <link href="http://yoursite.com/2019/02/18/graphql-translate/"/>
    <id>http://yoursite.com/2019/02/18/graphql-translate/</id>
    <published>2019-02-18T14:52:10.000Z</published>
    <updated>2021-01-02T10:50:07.333Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550915827036&amp;di=915d3dbc377cb034b3658fb54a0d0439&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180726%2F6e30a4612eb54d3b8b255777463ffd18.png" alt=""><br><a id="more"></a><br>原文地址：<a href="https://github.com/facebook/graphql/blob/master/README.md" target="_blank" rel="noopener">https://github.com/facebook/graphql/blob/master/README.md</a></p><p>我们可以在 <a href="https://facebook.github.io/graphql/" target="_blank" rel="noopener">https://facebook.github.io/graphql/</a> 最新发布的<a href="./spec">/spec</a>目录的markdown文件中找到 GraphQL的规范。</p><p>我们可以通过跟踪这个仓库最新的代码提交找到 <a href="https://facebook.github.io/graphql/draft/" target="_blank" rel="noopener">https://facebook.github.io/graphql/draft/</a> 中提到的最近的草案规范。</p><p>我们可以通过对应的 <a href="https://github.com/facebook/graphql/releases" target="_blank" rel="noopener">release tag</a> 在固定的链接找到 GrahpQL 之前的规范。例如，<a href="https://facebook.github.io/graphql/October2016/" target="_blank" rel="noopener">https://facebook.github.io/graphql/October2016/</a> ， 如果直接链接到 GraphQL 规范，则最好链接到特定引用版本的带有永久标记的链接。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a><a name="peg0ab"></a>概览</h2><p>这是一个由Facebook创建的 Api 查询语言规范。</p><p>GraphQL 的受众群体不是客户端开发者，而是那些对构建 GraphQL 开发和工具感兴趣的人。</p><p>为了被广泛采用，GraphQL 必须针对各种客户端、框架和语言，这需要跨项目和组织协作。它的规范是这项工作的协调点。</p><p>在这里可以找到需要的帮助 <a href="https://graphql.org/community/" target="_blank" rel="noopener">from the community</a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a><a name="i31iwq"></a>入门</h2><p>GraphQL 有类型系统、查询语言、语义执行器、静态类型检查和类型自检组成。为了使用户可以了解其中的每一个组件，我们已经完成了一个示例用来说明 GraphQL 的每一个部分。</p><p>这个示例不是全面的，但是它可以快速说明 GraphQL 的核心概念，在深入了解 <a href="https://github.com/graphql/graphql-js" target="_blank" rel="noopener">GraphQL.js</a>之前提供一些基本信息。</p><p>我们想用查询“星球大战三部曲”中人物和地点的信息来演示这个例子。</p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a><a name="uu5meg"></a>类型系统</h3><p>任何 GraphQL 的实现核心都是它可以返回对象类型的描述，在类型系统中描述并且在 Schema 中返回。</p><p>在我们“星球大战”的例子中，类型系统被定义在了此文件中 <a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsSchema.js" target="_blank" rel="noopener">starWarsSchema.js</a> 。</p><p>在系统中最多的基本类型是 Human,代表了人物，比如像 Luke,Leia 和 Han。在我们系统中所有的人类会有一个名字，所以我们定义 Human 类型必须有一个属性: name. 这个属性会返回一个字符串，并且我们知道这个字符串不是 null(就像每个人类都必须有一个名字一样）。所以我们定义 name 属性为 non-nullable String(非空字符串)。我们在系统规范和文档中始终使用简写符号，我们可以把 Human 类型描述为这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Human &#123;</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种简写是为了方便描述类型系统最基本的组成；Javascript 实现功能更全面，并允许记录类型和字段。<br>并且设置了类型系统和底层数据之间的映射关系；对于 GraphQ.js 中的测试用例，底层数据是一组 Javascript 对象<br><a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsData.js" target="_blank" rel="noopener">set of JavaScript objects</a> ，但是在大多数情况下，后台数据将通过某些服务进行访问，次类型系统层将负责从类型和字段大道该服务的映射。</p><p>许多 API 中的常见模式，在 GraphQL 中，是为对象提供用于重新获取对象的 ID。所以让我们把它添加到 Human 类型中，并且我们可以添加一个 string 类型的 homeplanet 字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Human &#123;</span><br><span class="line">id:String,</span><br><span class="line">  name:String,</span><br><span class="line">  homePlanet:String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们谈论的是星球大战三部曲，因此描述每个角色出现的剧集会很有用。为此，我们首先定义一个枚举，列出三部曲中的三集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emnu Episode &#123; NEWHOPE, EMPORE, JEDI&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以在 Human 中添加一个字段来描述他们出现在哪儿。这会返回一个剧集的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Human &#123;</span><br><span class="line">id:String,</span><br><span class="line">  name:String,</span><br><span class="line">  appearsIn:[Episode],</span><br><span class="line">  homeplanet:String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我来介绍一下另一个类型：<code>Droid</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Droid &#123;</span><br><span class="line"></span><br><span class="line">  id: String</span><br><span class="line"></span><br><span class="line">  name: String</span><br><span class="line"></span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line"></span><br><span class="line">  primaryFunction: String</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有两个类型！让我们添加一种方式来联系他们：人类和机器人都有朋友。但是人类可以同时和人类和机器人交朋友。我们如何区分人类还是机器人朋友呢？</p><p>如果我们看一下，我们会返现人来和机器人之间有共同的功能：他们都有 ID 、name和 episodes。所以我们可以添加一个接口，我们的类型系统目前是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123; NEWHOPE, EMPIRE, JEDI &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Character &#123;</span><br><span class="line"></span><br><span class="line">  id: String</span><br><span class="line"></span><br><span class="line">  name: String</span><br><span class="line"></span><br><span class="line">  friends: [Character]</span><br><span class="line"></span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Human implements Character &#123;</span><br><span class="line"></span><br><span class="line">  id: String</span><br><span class="line"></span><br><span class="line">  name: String</span><br><span class="line"></span><br><span class="line">  friends: [Character]</span><br><span class="line"></span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line"></span><br><span class="line">  homePlanet: String</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line"></span><br><span class="line">  id: String</span><br><span class="line"></span><br><span class="line">  name: String</span><br><span class="line"></span><br><span class="line">  friends: [Character]</span><br><span class="line"></span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line"></span><br><span class="line">  primaryFunction: String</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们或许会问一个问题，有任何字段可以返回 nul l吗？默认情况下，null 在任何GraphQL类型中都是合法的，然而<br>因为完成一个GraphQl查询通常需要和不同的服务端进行通信，这些服务端可能不会返回值。然而如果类型系统可以保证一个类型不会是null，这样的话我们可以把这个类型标记为非空。我们在类型后面加“！”来表示非空字段。我可以更新我们的系统以备注 id 永远不可能为空。</p><p>请注意，在我们当前的实现当中，我们可以保证任何字段都是非空的（因为我们当前的实现中有硬编码数据），<br>我们没有把他们标记为非空。可以想象，我们最终会用实际后端数据代替硬编码数据。通过这些配置，我们允许后端在发生错误的时候返回null,并且告知客户端后端发生了错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123; NEWHOPE, EMPIRE, JEDI &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Character &#123;</span><br><span class="line"></span><br><span class="line">  id: String!</span><br><span class="line"></span><br><span class="line">  name: String</span><br><span class="line"></span><br><span class="line">  friends: [Character]</span><br><span class="line"></span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Human implements Character &#123;</span><br><span class="line"></span><br><span class="line">  id: String!</span><br><span class="line"></span><br><span class="line">  name: String</span><br><span class="line"></span><br><span class="line">  friends: [Character]</span><br><span class="line"></span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line"></span><br><span class="line">  homePlanet: String</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line"></span><br><span class="line">  id: String!</span><br><span class="line"></span><br><span class="line">  name: String</span><br><span class="line"></span><br><span class="line">  friends: [Character]</span><br><span class="line"></span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line"></span><br><span class="line">  primaryFunction: String</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们错过了最后一部分：类型系统的主入口</p><p>当我们定义一个 Schema，我们定义了一个object类型，他是所有查询的基础。这个类型的名称通常被叫做 Query, 它描述了我们公共顶级API，我们在这个例子中的的 Query 类型看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">hero(episode:Eposode): Character</span><br><span class="line">  human(id:String): Human</span><br><span class="line">  droid(id:String):Droid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，有三个顶级操作，可以在我们的框架中被完成：</p><ul><li>hero 表示 谁是星战三部曲中的英雄人物，它设置了一个可选的参数允许我们查询特定剧集的英雄</li><li>human 接受一个非空参数ID作为查询条件来返回人物ID</li><li>droid 和droids保持一致</li></ul><p>这些字段演示了类型系统的另一个功能：特定参数的字段可以配置他们的行为。</p><p>当我们将整个类型系统打包到一起，将上面的 Query 类型定义为查询入口点，这将创建一个GraphQL Schema。</p><p>这个例子只是初步涉及到了类型系统的表层。这种规范在类型系统部分和 <a href="https://github.com/graphql/graphql-js/blob/master/src/type" target="_blank" rel="noopener">type</a> 目录中详细介绍了该主题。包含实现符合规范的GraphQL 的类型系统代码。</p><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a><a name="d8hgnw"></a>查询语法</h3><p>GraphQl 查询以声明方式描述了发行者希望从执行GraphQL 查询它们想要的数据。</p><p>在我们的星战例子中，<a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsQuery-test.js" target="_blank" rel="noopener">starWarsQueryTests.js</a> 文件是一个测试文件，它使用上面讨论的模式和一组样本数据，在<a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsData.js" target="_blank" rel="noopener">starWarsData.js</a>文件中。可以运行此测试文件来执行参考实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameQuery &#123;</span><br><span class="line"> hero &#123;</span><br><span class="line"> name</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行，query HeroNameQuery 定义来一个以schema的根查询类型为开头的操作名称 HeroNameQuery。综上所述，Query 有一个 hero 字段，返回一个Character 类型。Character 有一个String类型的name字段。这个查询的结果将会是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"hero"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"R2-D2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个GraphQL 文档定义多个操作时，指定查询关键词和一个操作名称是唯一的必要条件。所以我们可以用一个查询简写重写之前的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设GraphQL的后端服务数据将以R2-D2来标示hero。响应继续根据请求来变化；如果我们用这个查询来请求 R2-D2 的 ID和 friends 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriendsQuery &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  id</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">    id</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们会得到想这样的响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"hero"</span>:&#123;</span><br><span class="line">  <span class="attr">"id"</span>:<span class="string">"2001"</span>,</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"R2-D2"</span>,</span><br><span class="line">    <span class="attr">"friends"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="attr">"id"</span>:<span class="string">"1000"</span>,</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"Luke Skywalker"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="attr">"id"</span>:<span class="string">"1002"</span>,</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"Han solo"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="attr">"id"</span>:<span class="string">"1003"</span>,</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"Leia Organa"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Graphql 一个关键的方面是它的嵌套查询能力。在以上的查询中，我们请求了 R2-D2 的 friends，但是我们可以请求更多关于他们每个对象的信息。所以，让我们构造一个查询来请求 R2-D2 的 friends ，获取他们的名称和出现的剧集，然后再次嵌套查询他们每一个的 friends。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query NestedQuery &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  name</span><br><span class="line">    friends &#123;</span><br><span class="line">    name</span><br><span class="line">      appersIn</span><br><span class="line">      friends &#123;</span><br><span class="line">      name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"hero"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"R2-D2"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"friends"</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Luke Skywalker"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"appearsIn"</span>: [<span class="string">"NEWHOPE"</span>, <span class="string">"EMPIRE"</span>, <span class="string">"JEDI"</span>],</span><br><span class="line"></span><br><span class="line">        <span class="attr">"friends"</span>: [</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"Han Solo"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"Leia Organa"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"C-3PO"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"R2-D2"</span> &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Han Solo"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"appearsIn"</span>: [<span class="string">"NEWHOPE"</span>, <span class="string">"EMPIRE"</span>, <span class="string">"JEDI"</span>],</span><br><span class="line"></span><br><span class="line">        <span class="attr">"friends"</span>: [</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"Luke Skywalker"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"Leia Organa"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"R2-D2"</span> &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Leia Organa"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"appearsIn"</span>: [<span class="string">"NEWHOPE"</span>, <span class="string">"EMPIRE"</span>, <span class="string">"JEDI"</span>],</span><br><span class="line"></span><br><span class="line">        <span class="attr">"friends"</span>: [</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"Luke Skywalker"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"Han Solo"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"C-3PO"</span> &#125;,</span><br><span class="line"></span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"R2-D2"</span> &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的查询类型定义一种根据给定ID来查询 human 的方法。我们在查询用采用硬编码的ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query FetchLukeQuery &#123;</span><br><span class="line">human(id:&quot;1000&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"human"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"Luke Skywalker"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们可以定义一个具有参数的查询条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query FetchSomeIdQuery($someId:String!) &#123;</span><br><span class="line">human(id:$someId) &#123;</span><br><span class="line">  name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询现在有一个参数：\$someId;为了运行它，我们必须提供那个 ID。如果我们将 \$someId 设为“1000”，我们将获得 Luke。如果设为“1002”，我们将获得 Han。如果我们在这里传递了一个无效的 ID ，我将会得到 human 类型的 null，表明不存在这样的对象。</p><p>注意，在默认情况下响应中的键是字段的 name。为了用不同参数查询同一个字段时简洁明了或者避免键冲突，有时候修改这个键是很有用的。</p><p>我们可以用字段别名处理这种情况，如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query FeatchLukeAliased &#123;</span><br><span class="line">luke:human(id:&quot;1000&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 human 字段的结果别名为关键字 ”luke.现在响应是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"luke"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Luke Skywalker"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，键是 “luke” 而不是 “human”，就像我们之前的例子中没有使用别名一样。</p><p>这种方法在我们想要用两次同样的字段不同的参数时尤其有用，就像下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query FetchLukeAndLeiaAliased &#123;</span><br><span class="line">luke:human(id:&quot;1000&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">  &#125;</span><br><span class="line">  leia:human(id:&quot;1003&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们别名 human 的第一个结果到 luke ,并且第二个结果到 leia。所以结果是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"luke"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"Luke Skywalker"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"leia"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"Leia Organa"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想象，如果我们想要请求 Luke 和 Leia 的母星。我们可以这样做查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query DuplicateFields &#123;</span><br><span class="line">luke:human(id:&quot;1000&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">    homePlanet</span><br><span class="line">  &#125;</span><br><span class="line">  leia:human(id:&quot;1003&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">    homePlanet</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们已经可以看到这种方法会变得笨重，由于我们不得不添加新的字段到所有的查询部分。我们可以用提取公共字段到一个片段，并且将这个片段包含到查询中代替，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query useFragment &#123;</span><br><span class="line">luke:human(id:&quot;1000&quot;) &#123;</span><br><span class="line">  ...HumanFragment</span><br><span class="line">  &#125;</span><br><span class="line">  leia:human(id:&quot;1003&quot;) &#123;</span><br><span class="line">  ...HumanFragment</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">frament HumanFragment on Human &#123;</span><br><span class="line">name</span><br><span class="line">  homePlanet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个查询的结果是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"luke"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"Luke Skywalker"</span>,</span><br><span class="line">    <span class="attr">"homePlanet"</span>:<span class="string">"tatooine"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"leia"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"Leia Organa"</span>,</span><br><span class="line">    <span class="attr">"homePlanet"</span>:<span class="string">"Alderaan"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UseFragment 和 DuplicateFields 查询都获得相同的结果，但是 UseFragment 更简洁；如果我们想要添加更多字段，我们可以添加到公共的片段而不是拷贝到多个地方。</p><p>在上面我们定义了类型系统，所以我们知道输出中每个对象的类型；可以使用定一个在每个对象尚的特殊字段 __typename 来查询类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query CheckTypeOfR2 &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  __typename</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于R2-D2是 droid 类型，所以会返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"hero"</span>:&#123;</span><br><span class="line">  <span class="attr">"__typename"</span>:<span class="string">"Droid"</span>,</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"R2-D2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如果想要知道返回的具体类型。这是非常有用的，因为 hero 被定义为返回 Character 接口；如果我们反而请求第五集hero呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query CheckTypeOfLuke &#123;</span><br><span class="line">hero(episode:EMPIRE) &#123;</span><br><span class="line">  __typename</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会发现是 Luke</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"hero"</span>:&#123;</span><br><span class="line">  <span class="attr">"__typename"</span>:<span class="string">"Huamn"</span>,</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"Luke Skywalker"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与类型系统一样，这个例子只是触及到来查询语言的表层。该规范详细介绍来关于“语言”部分详情，并且，在GraphQL.js 中的 <a href="https://github.com/graphql/graphql-js/blob/master/src/language" target="_blank" rel="noopener">language</a> 目录包含来代码实现了一个规范兼容 GraphQL 查询语言解析器和词法分析器。</p><h3 id="校验系统"><a href="#校验系统" class="headerlink" title="校验系统"></a><a name="ll2dna"></a>校验系统</h3><p>通过使用类型系统，GraphQL 可以预见到一个查询是否有效。这种机制允许服务端或者客户端在无效查询被创建时有效到通知开发者，而不需要依赖运行时的检查。</p><p>在我们的星战例子中，<a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsValidation-test.js" target="_blank" rel="noopener">starWarsValidationTests.js</a> 文件中包含了一些常见的示范查询，并且是一个可运行来练习参考实现校验器的测试文件。</p><p>首先，让我们取一个复杂的校验查询。这是一个来自上面部分嵌套查询的例子，但是将重复的字段考虑在一个片段内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">query NestedQueryWithFragment &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  ...NameAndAppearances</span><br><span class="line">    friends&#123;</span><br><span class="line">    ...NameAndAppearances</span><br><span class="line">      friends&#123;</span><br><span class="line">      ...NameAndAppearances</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fragment NameAndAppearances on Character &#123;</span><br><span class="line">name</span><br><span class="line">  appearsIn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且这个查询是有效的。让我们看一写无效的查询。</p><p>当我们查询字段时，我们必须查询一个在给定类型中存在的字段。例如 hero 返回 Character 类型，我们必须在 Character 上查询一个字段。那个类型不存在 favoriteSpaceship 字段，所以这个查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#INVALID:favoriteSpaceship does not exist on Charcter</span><br><span class="line">query HeroSpaceshipQuery &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  favoriteSpaceship</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是无效的。</p><p>每当我们查询一个字段并且它返回的不是标量或者枚举，我们必须指定我们想要从字段中获取的数据。Hero 返回 Character 类型，我们一直在请求像 name 和 appearsIn 这样的字段；如果我们忽略这一点，这个查询将会变得无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># INVALID: hero is not a scalar, so fields are needed</span><br><span class="line">query HeroNoFieldsQuery &#123;</span><br><span class="line">hero</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，如果是标量，则查询其他的字段没有意义，这样也会将查询变得无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># INVALID: name is a scalar, so fields are not permitted</span><br><span class="line">queryHeroFieldsOnScalarQuery &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  name &#123;</span><br><span class="line">    firstCharacterOfName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前，有人在问题中指出一个查询只能查询类型中有的字段；当我们查询将返回 CHaracter 类型的 hero 时，我们只能查询 Character 中存在的字段。但是，如果我们像查询 R2-D2 中主要功能会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># INVALID: primaryFunction does not exist on Character</span><br><span class="line">query DriodFieldsOnCaracter &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  name</span><br><span class="line">    primaryFunction</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个查询是无效的，因为 primaryFunction 不是 Character 中的字段。我们想要一种方式来表示我们希望查询 primaryFunction 如果 Character 是 Droid，否则忽律这个字段。我们可以利用我之前介绍的 fragments 来做这件事。通过设置一个被定义在 Droid 的 fragment 并包含它，我们确保我们仅查询 primaryFunction 被定义的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query DriodFieldInFragment &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  name</span><br><span class="line">    ...DriodFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fragment DriodFields on Driod &#123;</span><br><span class="line">primaryFunction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询是有效的，但是它有点冗长。当我们多次使用时，命名片段才是有价值的，但是我们只用了一次。<br>相比与命名一个片段，我们可以用一个行内片段；这仍然允许我们表示我们正在查询的类型，但是不用命名一个分开的片段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query DriodFieldsInINLineFragment &#123;</span><br><span class="line">hero &#123;</span><br><span class="line">  name</span><br><span class="line">    ...on Driod &#123;</span><br><span class="line">    primaryFucntion</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这仅仅是触及到了校验系统的表面；那里有许多校验规则来确保 GraphQL 查询在语义上是有意义的。该规范介绍了更多的关于校验主题的详细信息，并且<a href="https://github.com/graphql/graphql-js/blob/master/src/validation" target="_blank" rel="noopener">validation</a> 目录包含了代码实现一个 GraphQL 校验器的兼容规范。</p><h3 id="自我检查"><a href="#自我检查" class="headerlink" title="自我检查"></a><a name="1yg4bi"></a>自我检查</h3><p>向 GraphQL  架构询问有关于它支持的查询信息通常是很有用的。GraphQL 允许我们通过自我检查系统这样做。</p><p>在我们的星战例子中，<a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsIntrospection-test.js" target="_blank" rel="noopener">starWarsIntrospectionTests.js</a> 文件包含了一些自我检查系统的示范查询，并且这是一个可以运行来练习参考实现自我检查系统的测试文件。</p><p>我们设计来类型系统，所以我们知道可用的数据类型，但是如果我们没有，我们可以询问 GraphQL ，通过查询 __schema 字段（总是可以查询的根数据类型）。让我们现在开始这样做并且询问什么类型是有效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query IntrospectionTypeQuery &#123;</span><br><span class="line">__schema &#123;</span><br><span class="line">  types &#123;</span><br><span class="line">    name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"__schema"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"types"</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Query"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Character"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Human"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"String"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Episode"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Droid"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"__Schema"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"__Type"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"__TypeKind"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Boolean"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"__Field"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"__InputValue"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"__EnumValue"</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"__Directive"</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哇哦，那是很多数据类型。他们是什么？让我对他们进行分组：</p><ul><li><p><strong>Query, Character, Human, Episode, Droid</strong> - 这些在我们类型系统中定义的。</p></li><li><p><strong>String, Boolean</strong> - 这些是类型系统提供的标准类型。</p></li><li><strong>Schema, </strong>Type, <strong>Field, </strong>InputValue, <strong>EnumValue,</strong>Directive - 这些都是以双下划线开头，表示他们是自我检查系统的一部分。</li></ul><p>现在，让我们尝试并且找出一个开始有效查询的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query InstrospectionQueryTypeQuery &#123;</span><br><span class="line">__schema &#123;</span><br><span class="line">  queryType &#123;</span><br><span class="line">    name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得到的结果是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"__schema"</span>:&#123;</span><br><span class="line">  <span class="attr">"queryType"</span>:&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"Query"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且那个是符合我们在类型系统所介绍的：Query 类型是我们开始的地方。注意这里的命名是按照惯例的。我们可以命名我们的<code>Query</code>类型 否则，如果我们指定它，它仍然会在这里返回 作为查询的起始类型。但是命名为<code>Query</code>是有用的 惯例。</p><p>检查一个具体的类型通常是有用的。让我们看看 Droid 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query InstrospectionDroidTypeQuery &#123;</span><br><span class="line">__type(name:&quot;Droid&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会得到结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>:&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"Droid"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们向了解更多关于 Droid 。例如，它是一个接口还是对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query IntrospectionDroidKindQuery &#123;</span><br><span class="line">__tyoe(name:&quot;Doid&quot;) &#123;</span><br><span class="line">  name,</span><br><span class="line">    kind</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们会得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"__type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Droid"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"kind"</span>: <span class="string">"OBJECT"</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kind 返回一个 __TypeKind ，其中一个值是 OBJECT。如果我们查询 Character 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query InstrospectionCharacterKindQuery &#123;</span><br><span class="line">__type(name:&quot;Character&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">    kind</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们会得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"__type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Character"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"kind"</span>: <span class="string">"INTERFACE"</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现它是一个接口类型。</p><p>一个对象知道什么字段是可用的很有用，所以关于 Droid 询问自我检查系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query InstrospectionDroidFiedldsQuery &#123;</span><br><span class="line">__type(name:&quot;Droid&quot;) &#123;</span><br><span class="line">  name</span><br><span class="line">    fields &#123;</span><br><span class="line">    name</span><br><span class="line">      type &#123;</span><br><span class="line">      name</span><br><span class="line">        kind</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们会得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"__type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Droid"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"fields"</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"id"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"NON_NULL"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"name"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"String"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"SCALAR"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"friends"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"LIST"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"appearsIn"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"LIST"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"primaryFunction"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"String"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"SCALAR"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们是我们定义在 Droid 上面的字段。</p><p>id 在这里看起来有点奇怪，它没有该类型的名称。那是因为它是一种<br>为 NON_NULL 的包装类型。如果我们查询该字段类型的 ofType，我们可以在这里找到 String 类型，告诉我们这是一个非空的字符串。</p><p>同样，friends 和 appearsIn 都没有 name，因为它们是 LIST 的包装类型。我们在这些类型中查询 ofType，告诉我们这些是什么列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">query IntrospectionDroidWrappedFieldsQuery &#123;</span><br><span class="line"></span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line"></span><br><span class="line">    fields &#123;</span><br><span class="line"></span><br><span class="line">      name</span><br><span class="line"></span><br><span class="line">      type &#123;</span><br><span class="line"></span><br><span class="line">        name</span><br><span class="line"></span><br><span class="line">        kind</span><br><span class="line"></span><br><span class="line">        ofType &#123;</span><br><span class="line"></span><br><span class="line">          name</span><br><span class="line"></span><br><span class="line">          kind</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们会得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"__type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Droid"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"fields"</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"id"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"NON_NULL"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"ofType"</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"String"</span>,</span><br><span class="line"></span><br><span class="line">            <span class="attr">"kind"</span>: <span class="string">"SCALAR"</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"name"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"String"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"SCALAR"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"ofType"</span>: <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"friends"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"LIST"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"ofType"</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Character"</span>,</span><br><span class="line"></span><br><span class="line">            <span class="attr">"kind"</span>: <span class="string">"INTERFACE"</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"appearsIn"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"LIST"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"ofType"</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Episode"</span>,</span><br><span class="line"></span><br><span class="line">            <span class="attr">"kind"</span>: <span class="string">"ENUM"</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"primaryFunction"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"String"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"SCALAR"</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">"ofType"</span>: <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个自我检查系统的工具特性结束尤其有用；让我们查询文档系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query IntrospectionDroidDescriptionQuery &#123;</span><br><span class="line"></span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line"></span><br><span class="line">    description</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产出是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"__type"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Droid"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"A mechanical creature in the Star Wars universe."</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以我们可以用自我检查系统来访问类型系统的文档，并且可以创建浏览器文档或者富应用 IDE 工具。</p><p>这也只是触及到来自我检查系统的表面；我们可以查询枚举值，类型实现的接口等待。我们甚至可以检查自我检查系统本省。在 Introspection 部分可以看到相关主题的更多详细信息，并且 <a href="https://github.com/graphql/graphql-js/blob/master/src/type/introspection.js" target="_blank" rel="noopener">introspection</a> 文件包含了自我检查系统查询的兼容规范代码实现。</p><h3 id="其它内容"><a href="#其它内容" class="headerlink" title="其它内容"></a><a name="e8pyxk"></a>其它内容</h3><p>这个自述文件介绍了有关于类型系统，查询执行，校验和自我检查系统的参考实现。<a href="https://github.com/graphql/graphql-js/" target="_blank" rel="noopener">GraphQL.js</a> 和规范中还有更多信息，包含了执行查询，响应格式化，解释类型系统如何映射到底层实现，GraphQL 响应格式化和 GraphQL 的语法描述和实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1550915827036&amp;amp;di=915d3dbc377cb034b3658fb54a0d0439&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180726%2F6e30a4612eb54d3b8b255777463ffd18.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译计划" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="GraphQl" scheme="http://yoursite.com/tags/GraphQl/"/>
    
  </entry>
  
  <entry>
    <title>Vue防坑指南</title>
    <link href="http://yoursite.com/2019/02/03/Vue%E9%98%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/02/03/Vue防坑指南/</id>
    <published>2019-02-03T00:56:52.000Z</published>
    <updated>2021-01-02T10:50:07.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/169573/pexels-photo-169573.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940" alt=""><br><a id="more"></a><br><a name="75c4d379"></a></p><h3 id="对象属性添加与删除"><a href="#对象属性添加与删除" class="headerlink" title="对象属性添加与删除"></a>对象属性添加与删除</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">data() &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.b = <span class="string">"xxxx"</span> <span class="comment">//非响应</span></span><br><span class="line">vm.a = <span class="string">"xxx"</span> <span class="comment">//响应</span></span><br><span class="line"></span><br><span class="line">vm.$set(<span class="string">'b'</span>,<span class="string">"xxxx"</span>)<span class="comment">//响应</span></span><br></pre></td></tr></table></figure><p>Vue 不能检测以上属性添加或删除的变化，必须使用 Vue.set 或者 vm.$set 设置属性</p><p><a name="df352415"></a></p><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>Vue 无法检测到以下更新：</p><ul><li>单独设置数据中某一项元素</li><li>变更数据长度</li></ul><p>替代的解决方案是使用 vm.$set 方法,删除数据某一项使用 splice 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    items:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.$set(vm.items,index,item)</span><br><span class="line">vm.items.splice(newLength)</span><br><span class="line">vm.items.splice(itemIndex,<span class="number">1</span>)</span><br><span class="line">vm.items.push(item)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><a name="aab349d2"></a></p><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>以”_”,”$”为开头命名的变量不会被 Vue 代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;span&gt;&#123;&#123;_a&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;span&gt;&#123;&#123;$b&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">data() &#123;</span><br><span class="line">  _a:<span class="number">1</span>,</span><br><span class="line">     $b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm._a = <span class="number">3</span> <span class="comment">//不会响应</span></span><br><span class="line">vm.$b = <span class="number">4</span> <span class="comment">//不会响应</span></span><br></pre></td></tr></table></figure><p><a name="edfbb65b"></a></p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>在自定义 Vue 组件上绑定原生事件需要加 .native 修饰符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">click.native</span>=<span class="string">"handleClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="fec3d6e4"></a></p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>组件内部创建的定时器要及时销毁，防止内存溢出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;,<span class="number">10000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestory() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="232b0de8"></a></p><h3 id="dom操作"><a href="#dom操作" class="headerlink" title="dom操作"></a>dom操作</h3><p>需要在dom操作之后执行的操作要放到$nexTick中执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">///.......</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/169573/pexels-photo-169573.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;dpr=2&amp;amp;h=650&amp;amp;w=940&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>React树组件开发</title>
    <link href="http://yoursite.com/2019/01/18/react-ztree/"/>
    <id>http://yoursite.com/2019/01/18/react-ztree/</id>
    <published>2019-01-18T15:37:11.000Z</published>
    <updated>2021-01-02T10:50:07.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1482062364825-616fd23b8fc1?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=800&amp;q=60" alt=""><br><a id="more"></a></p><h2 id="开发目的"><a href="#开发目的" class="headerlink" title="开发目的"></a>开发目的</h2><p>项目中经常会用到树形控件，而且数据量较大，通常会达到上万的数据量，之前用的jQuery ztree 可以很好的满足以上要求，而自己目前也没有能力造一个满足这样要求的轮子，所以还是延用之前的ztree，然后在其之上封装成react component形式。</p><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><p>首先我们新建一个项目目录，这里我们采用webpack umd打包方式，使其可以用于amd，cmd和全局引用.<br>项目目录是这样滴~<br><img src="//img.mukewang.com/5b0ea3570001898603500512.png" alt="图片描述"></p><p>src 中ztree-for-react.js 是源码，经过webpack编译打包后的文件会保存到lib目录中</p><p>webpack 配置如下图所示：<br><img src="//img.mukewang.com/5b0eb2800001a0d110580861.png" alt="图片描述"></p><p>接下来我们编写核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;   <span class="comment">//加载jQuery</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'ztree'</span>;  <span class="comment">//加载ztree</span></span><br><span class="line"><span class="keyword">let</span> ztreeIndex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactZtree</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.renderZtreeDom();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate()&#123;</span><br><span class="line">    <span class="keyword">this</span>.renderZtreeDom();</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.ztreeObj.destory();</span><br><span class="line">  &#125;</span><br><span class="line">  renderZtreeDom()&#123;</span><br><span class="line">    <span class="keyword">let</span> ztreeObj = <span class="keyword">this</span>.ztreeObj=$.fn.zTree.init(<span class="keyword">this</span>.getTreeDom(),<span class="keyword">this</span>.getTreeSetting(),<span class="keyword">this</span>.props.nodes);</span><br><span class="line">    <span class="keyword">return</span> ztreeObj;</span><br><span class="line">  &#125;</span><br><span class="line">  getTreeDom()&#123;</span><br><span class="line">    <span class="keyword">return</span> $(<span class="keyword">this</span>.refs.ztree);</span><br><span class="line">  &#125;</span><br><span class="line">  getTreeSetting()&#123;</span><br><span class="line">    <span class="keyword">let</span> props=<span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      treeId:props.treeId,</span><br><span class="line">      treeObj:props.treeObj,</span><br><span class="line">      <span class="keyword">async</span>:props.async,</span><br><span class="line">      callback:props.events,</span><br><span class="line">      check:props.check,</span><br><span class="line">      data:props.data,</span><br><span class="line">      edit:props.edit,</span><br><span class="line">      view:props.view</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getTreeObj()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ztreeObj;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"ztree"</span> ref=<span class="string">"ztree"</span> id=&#123;<span class="string">`ztree_<span class="subst">$&#123;ztreeIndex++&#125;</span>`</span>&#125;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们在componentDidMount 钩子函数中初始化ztree，利用getTreeSetting方法写入ztree的配置，将ztree的配置转换为React组件的props，当树节点或者配置更新时我们调用ztree distroy方法销毁ztree对象并且重新初始化ztree，这样就达到了当外部props属性改变是ztree可以自动刷新的效果,这样一个ztree组件就大功告成啦~</p><p>最后附上这个项目的<a href="https://github.com/arixse/ztree-for-react" target="_blank" rel="noopener">github地址</a>,喜欢的童鞋可以star或者fork，也非常欢迎提issues来帮忙进一步改进和完善这个组件。目前npm包也已经发布，有需要的同学可以使用npm安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ztree-for-react</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1482062364825-616fd23b8fc1?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=800&amp;amp;q=60&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>基于D3.js的力导向图开发实践</title>
    <link href="http://yoursite.com/2019/01/18/d3-test/"/>
    <id>http://yoursite.com/2019/01/18/d3-test/</id>
    <published>2019-01-18T15:04:19.000Z</published>
    <updated>2021-01-02T10:50:07.332Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://d3js.org.cn/home.png" alt=""><br><a id="more"></a></p><h1 id="D3初体验"><a href="#D3初体验" class="headerlink" title="D3初体验"></a>D3初体验</h1><p>说到前端数据可视化，就不得不提到鼎鼎大名的d3.js。之前因为公司一直都在用echarts,所以对d3了解的不多。幸好前几个星期有个项目要实现一个人物关系的力导向图，并且人物图片要实现圆形。经过在网上查找资料后发现echarts并没有这样的功能，所以就想到了用d3来实现，最终实现的效果大体是这样滴~<br><img src="https://cdn.nlark.com/yuque/0/2019/png/149846/1547784052478-e1036227-99b9-458d-8090-41473f20e267.png#align=left&amp;display=inline&amp;height=642&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=642&amp;originWidth=769&amp;size=120895&amp;width=769" alt="image.png"><br>说说大体的实现思路：</p><h3 id="1-构建力导向图"><a href="#1-构建力导向图" class="headerlink" title="1.构建力导向图"></a>1.构建力导向图</h3><p><em>目前我用的d3版本是v5.7.0</em><br>直接上代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="number">1170</span>,</span><br><span class="line">height = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">var</span> imgSize = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">var</span> svg = d3</span><br><span class="line">.select(<span class="string">"body"</span>)</span><br><span class="line">.append(<span class="string">"svg"</span>)</span><br><span class="line">.attr(<span class="string">"width"</span>, width)</span><br><span class="line">.attr(<span class="string">"height"</span>, height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> simulation = d3</span><br><span class="line">.forceSimulation()</span><br><span class="line">.alpha(<span class="number">0.2</span>)</span><br><span class="line">.force(</span><br><span class="line"><span class="string">"link"</span>,</span><br><span class="line">d3.forceLink().id(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> d.id;</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br><span class="line">.force(</span><br><span class="line"><span class="string">"charge"</span>,</span><br><span class="line">d3</span><br><span class="line">.forceManyBody()</span><br><span class="line">.distanceMin(<span class="number">200</span>)</span><br><span class="line">.strength(<span class="number">-250</span>)</span><br><span class="line">)</span><br><span class="line">.force(<span class="string">"center"</span>, d3.forceCenter(width / <span class="number">2</span>, height / <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>首先我们去生成一个svg节点，利用d3基本的api就可以实现，然后根据官方文档的介绍，我们要生成一个simulation，我称它为模拟器，这个是最主要的，我们利用d3.forceSimulation这个方法生成了一个力导向图的模拟器，这个相当于是一个力导向图的框架，之后我们可以在这个框架上面添加我们需要的节点和连线</p><h3 id="2-创建节点"><a href="#2-创建节点" class="headerlink" title="2. 创建节点"></a>2. 创建节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">svg.append(<span class="string">"defs"</span>)</span><br><span class="line">.selectAll(<span class="string">"pattern"</span>)</span><br><span class="line">.data(graph.nodes)</span><br><span class="line">.enter()</span><br><span class="line">.append(<span class="string">"pattern"</span>)</span><br><span class="line">.attr(<span class="string">"patternUnits"</span>, <span class="string">"objectBoundingBox"</span>)</span><br><span class="line">.attr(<span class="string">"patternContentUnits"</span>, <span class="string">"userSpaceOnUse"</span>)</span><br><span class="line">.attr(<span class="string">"id"</span>, d =&gt; d.id)</span><br><span class="line">.attr(<span class="string">"width"</span>, <span class="number">1.0</span>)</span><br><span class="line">.attr(<span class="string">"height"</span>, <span class="number">1.0</span>)</span><br><span class="line">.append(<span class="string">"image"</span>)</span><br><span class="line">.attr(<span class="string">"width"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.main) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">178</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> imgSize;</span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"height"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.main) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">178</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> imgSize;</span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"xlink:href"</span>, d =&gt; d.image)</span><br><span class="line">.attr(<span class="string">"x"</span>, <span class="number">0</span>)</span><br><span class="line">.attr(<span class="string">"y"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.main) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>d3选择器的用法和jQuery选择器用法类似，如果没有接触过可以自行查看相关文档，下面说下enter和exit的用法</p><h4 id="enter"><a href="#enter" class="headerlink" title="enter()"></a>enter()</h4><p>返回数组数据相比对应节点数据多余出的那部分数据，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(<span class="string">'line'</span>)</span><br><span class="line">.data(data)</span><br><span class="line">.append(<span class="string">'line'</span>)</span><br><span class="line">.attr(<span class="string">'stroke'</span>,<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>selectAll选中当前文档中所有line节点，如果line节点的个数为n,data数组长度为m，则enter选中的数据为n-m长度的data集合，以上代码会将少的那部分line节点上去。</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h4><p>返回选中节点比数据长度多的那部分节点集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">'text'</span>)</span><br><span class="line">.data(data) <span class="comment">//data.length==n</span></span><br><span class="line">.exit() </span><br><span class="line">.remove()</span><br></pre></td></tr></table></figure><p>以上代码执行后会将多余的text节点删除</p><h3 id="3-创建连线和文字"><a href="#3-创建连线和文字" class="headerlink" title="3. 创建连线和文字"></a>3. 创建连线和文字</h3><p>连线：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = svg</span><br><span class="line">.append(<span class="string">"g"</span>)</span><br><span class="line">.attr(<span class="string">"class"</span>, <span class="string">"links"</span>)</span><br><span class="line">.selectAll(<span class="string">"line"</span>)</span><br><span class="line">.data(graph.links)</span><br><span class="line">.enter()</span><br><span class="line">.append(<span class="string">"line"</span>)</span><br><span class="line">.attr(<span class="string">"stroke"</span>, <span class="string">"#00a0e9"</span>);</span><br></pre></td></tr></table></figure></p><p>文字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linkText = svg</span><br><span class="line">.append(<span class="string">"g"</span>)</span><br><span class="line">.selectAll(<span class="string">"circle"</span>)</span><br><span class="line">.data(graph.nodes.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.empty))</span><br><span class="line">.enter()</span><br><span class="line">.append(<span class="string">"text"</span>)</span><br><span class="line">.text(<span class="function"><span class="params">d</span> =&gt;</span> d.id);</span><br></pre></td></tr></table></figure></p><p>创建连线和显示文字和创建节点的逻辑基本一样，只是选中的数据不同</p><h3 id="4-连接节点和连线"><a href="#4-连接节点和连线" class="headerlink" title="4.连接节点和连线"></a>4.连接节点和连线</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">simulation</span><br><span class="line">.nodes(graph.nodes)</span><br><span class="line">.on(<span class="string">"tick"</span>, ticked)</span><br><span class="line">.force(<span class="string">"link"</span>)</span><br><span class="line">.links(graph.links);</span><br></pre></td></tr></table></figure><p>在节点和连线都准备好的前提下我们可以将节点和连线关联起来，用simulation.nodes 和simulation.force(“link”).links()方法。<br>在这里要提下tick事件，节点和连线每次更新都会触发tick事件，因此我们要给tick事件增加回调函数，来更新节点和连线还有文字的位置。<br>下面是ticked代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ticked</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">node.attr(<span class="string">"cx"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.main) &#123;</span><br><span class="line"><span class="keyword">return</span> width / <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.x &lt;= imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> imgSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.x &gt;= width - imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> width - imgSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.x;</span><br><span class="line">&#125;).attr(<span class="string">"cy"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.main) &#123;</span><br><span class="line"><span class="keyword">return</span> height / <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.y &lt;= imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> imgSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.y &gt;= height) &#123;</span><br><span class="line"><span class="keyword">return</span> height - imgSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.y;</span><br><span class="line">&#125;);</span><br><span class="line">link.attr(<span class="string">"x1"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.source.main) &#123;</span><br><span class="line"><span class="keyword">return</span> width / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.source.x;</span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"y1"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.source.main) &#123;</span><br><span class="line"><span class="keyword">return</span> height / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.source.y;</span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"x2"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.target.x &lt;= imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> imgSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.target.x &gt;= width - imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> width - imgSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.target.x;</span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"y2"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.target.y &lt;= imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> imgSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.target.y &gt;= height - imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> height - imgSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.target.y;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">linkText</span><br><span class="line">.attr(<span class="string">"x"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.main) &#123;</span><br><span class="line"><span class="keyword">return</span> width / <span class="number">2</span> - <span class="number">20</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.x &lt;= imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> imgSize - <span class="number">20</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.x &gt;= width - imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> width - imgSize - <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.x<span class="number">-20</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"y"</span>, d =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (d.main) &#123;</span><br><span class="line"><span class="keyword">return</span> height / <span class="number">2</span> + <span class="number">110</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.y &lt;= imgSize) &#123;</span><br><span class="line"><span class="keyword">return</span> imgSize + <span class="number">50</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d.y &gt;= height) &#123;</span><br><span class="line"><span class="keyword">return</span> height - imgSize +<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.y+<span class="number">50</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我检测了下边界值，为了不让节点和连线超出边界，但是现在用这样的方法重置节点和连线的位置在拖拽的时候会非常生硬，在广泛查了资料后还是没有找到比较好的解决方法，希望有办法的同学告知~:)</p><h3 id="5-实现拖拽"><a href="#5-实现拖拽" class="headerlink" title="5. 实现拖拽"></a>5. 实现拖拽</h3><p>实现拖拽需要调用d3.drag，这里采用call方法调用drag方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nodes.call(</span><br><span class="line">  d3.drag()</span><br><span class="line">  .on(<span class="string">"start"</span>,dragstarted)</span><br><span class="line">  .on(<span class="string">"drag"</span>,dragged)</span><br><span class="line">  .on(<span class="string">"end"</span>,dragended)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragstarted</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d3.event.active) simulation.alphaTarget(<span class="number">0.3</span>).restart();</span><br><span class="line">d.fx = d.x;</span><br><span class="line">d.fy = d.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragged</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">d.fx = d3.event.x;</span><br><span class="line">d.fy = d3.event.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragended</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d3.event.active) simulation.alphaTarget(<span class="number">0</span>);</span><br><span class="line">d.fx = <span class="literal">null</span>;</span><br><span class="line">d.fy = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里绑定了拖拽的三个时间，分别是开始，拖拽中和拖拽结束。在三个事件回调中去更新节点位置。</p><h3 id="6-圆形图片"><a href="#6-圆形图片" class="headerlink" title="6. 圆形图片"></a>6. 圆形图片</h3><p>由于初始状态下nodes采用的并不是圆形图片，要实现圆形图片需要借助于svg中circle和pattern标签。关于这方面我是参考的这篇文章来做的 <a href="https://www.zhangxinxu.com/wordpress/2014/06/svg-canvas-image-border-radius/" target="_blank" rel="noopener">svg圆角</a>。<br>首先对于每一个node节点对应生成pattern标签，用g标签做分组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = <span class="built_in">Date</span>.now()</span><br><span class="line">svg.append(<span class="string">"defs"</span>)</span><br><span class="line">.data(data.graph)</span><br><span class="line">.append(<span class="string">"pattern"</span>)</span><br><span class="line">.attr(<span class="string">"patternUnits"</span>,<span class="string">"objectBoundingBox"</span>)</span><br><span class="line">.attr(<span class="string">"patternContentUnits"</span>,<span class="string">"userSpaceOnUse"</span>)</span><br><span class="line">.attr(<span class="string">"id"</span>,d=&gt;d.id+<span class="string">'_'</span>+ timestamp)</span><br><span class="line">.append(<span class="string">"image"</span>)</span><br><span class="line">.attr(<span class="string">"xlink:href"</span>,d=&gt;d.imageUrl)</span><br><span class="line">nodes.selectAll(<span class="string">"circle"</span>)</span><br><span class="line">.data(data.graph)</span><br><span class="line">.append(<span class="string">"circle"</span>)</span><br><span class="line">.attr(<span class="string">"fill"</span>,d=&gt;<span class="string">`url(#<span class="subst">$&#123;d.id&#125;</span>_<span class="subst">$&#123;timestamp&#125;</span>)`</span>)</span><br></pre></td></tr></table></figure><p>这里先缓存一个一个当前时间戳变量，方便后面为pattern标签生成唯一的id，然后在svg中添加一个defs标签，defs标签用法可以参考相关资料，在这里就不多说啦。然后在defs中添加多个pattern，为每一个pattern生成唯一的id，方便后面circle标签引用。由于需求中提到主节点和其他分支节点的大小不一样，所以我在这里设置为pattern设置了patternUnits属性,这个属性可以方便用户定义pattern大小。</p><h4 id="patternUnits"><a href="#patternUnits" class="headerlink" title="patternUnits"></a>patternUnits</h4><ol><li>objectBoundingBox：设置pattern 大小为相对值，设置范围是0~1</li><li>userSpaceOnUser: 设置pattern大小为绝对值<h4 id="patternContentUnits"><a href="#patternContentUnits" class="headerlink" title="patternContentUnits"></a>patternContentUnits</h4></li><li>objectBoundingBox：设置pattern中内容大小为相对值，设置范围是0~1</li><li>userSpaceOnUser: 设置pattern中内容大小为绝对值</li></ol><p>相关资料可以参考w3cplus上面相关文章：<br><a href="https://www.w3cplus.com/svg/svg-pattern-element.html" target="_blank" rel="noopener">https://www.w3cplus.com/svg/svg-pattern-element.html</a></p><p>该效果的主体 内容就这么多，至于图片后面蓝色小点纯粹是为了装饰用，在实际中没有意义。相关实现思路为在每个图片节点后面添加三个小节点数据，然后加上对应的标志，在更新位置与设置样式的时候与其他节点区别对待。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setEmptyNodes</span>(<span class="params">data, num</span>) </span>&#123;</span><br><span class="line">data.nodes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!item.main) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">data.nodes.push(&#123;</span><br><span class="line">id: <span class="string">`<span class="subst">$&#123;item.id&#125;</span>_empty_<span class="subst">$&#123;i&#125;</span>`</span>,</span><br><span class="line">name: <span class="string">``</span>,</span><br><span class="line">empty: <span class="literal">true</span>,</span><br><span class="line">parentNode: item.id</span><br><span class="line">&#125;);</span><br><span class="line">data.links.push(&#123;</span><br><span class="line">source: item.id,</span><br><span class="line">target: <span class="string">`<span class="subst">$&#123;item.id&#125;</span>_empty_<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，一个简单的力导向图就大功告成啦。</p><h3 id="7-感受"><a href="#7-感受" class="headerlink" title="7.感受"></a>7.感受</h3><p>d3不愧是前端数据可视化最流行的框架，用了一次就感受到了它无比强大。想比echarts来说，d3更灵活，可以实现更加丰富的效果。最后附上d3的官网地址 <a href="https://d3js.org/" target="_blank" rel="noopener">https://d3js.org/</a>。希望还没有使用过d3的小伙伴们可以在以后的工作过程中运用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://d3js.org.cn/home.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="D3" scheme="http://yoursite.com/tags/D3/"/>
    
      <category term="数据可视化" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="图表" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%A1%A8/"/>
    
      <category term="chart" scheme="http://yoursite.com/tags/chart/"/>
    
  </entry>
  
</feed>
